\documentclass[handout,xcolor=pdftex,romanian,colorlinks]{beamer}
\usepackage{../tslides}

\title[SLP---SOS]{Semantica Limbajelor de programare}
\subtitle{Semantica tranzițională}
\begin{document}
\maketitle

\begin{section}{Semantica tranzițională}
\begin{frame}{Semantica tranzițională}{}
\begin{itemize}
\item Introdusă de Gordon Plotkin (1981) ca 

\hfill  \structure{S}emantică \structure{O}perațională \structure{S}tructurală (SOS) \hfill \;
\item Denumiri alternative: 

\hfill „semantica pașilor mici”, „semantică prin reducere"\hfill \;
\item Definește cel mai mic pas de execuție 
\item Relație „de tranziție” între configurații definită recursiv prin reguli:
$$\Ss{\c{{\it Cod}, {\it Stare}}}{\c{{\it Cod'}, {\it Stare'}}}$$
\item Fiecare pas de execuție este concluzia unei demonstrații
\item Execuția se obține ca o succesiune de astfel de tranziții:

$\begin{array}{l}
\c{\alert{x \terminal{:=} 0} \terminal{;}  x \terminal{:=} {\terminal{!} x} \terminal{+} 1,\emptyset}
\longrightarrow
\c{\alert{{\terminal{skip}} \terminal{;}  x \terminal{:=} {\terminal{!} x} \terminal{+} 1},\{x \mapsto 0\}}
\longrightarrow
\\
\c{x \terminal{:=} \alert{\terminal{!} x} \terminal{+} 1,\{x \mapsto 0\}}
\longrightarrow
\c{x \terminal{:=} \alert{0 \terminal{+} 1},\{x \mapsto 0\}}
\longrightarrow
\\
\c{\alert{x \terminal{:=} 1},\{x \mapsto 0\}}
\longrightarrow
\c{\terminal{skip},\{x \mapsto 1\}}
\end{array}$
\end{itemize}
\end{frame}

\begin{frame}{Redex. Reguli structurale. Axiome}
\begin{block}{\alert{Ex}presie \alert{red}uctibilă --- \alert{redex}}
Reprezintă fragmentul de sintaxă care va fi modificat la următorul pas.

\hfill$\Sif 0 \terminal{<=} 5 \terminal{+} (7 \terminal{*} \alert<2->{\terminal{!} x}) \Sthen  r \terminal{:=}1 \Selse r \terminal{:=}0 $\hfill\ 
\end{block}

\begin{block}{Reguli structurale --- Folosesc la identificarea următorului redex}
\begin{itemize}
\item Definite recursiv pe structura termenilor
\end{itemize}
\onslide<3->{
$$\reg{
 \Ss{\c{\Sif  \alert{b} \Sthen c_1 \Selse c_2,\sigma}}{\c{\Sif \structure{b'} \Sthen c_1 \Selse c_2,\structure{\sigma'}}}
}{
  \Ss{\c{b,\sigma}}{\c{b',\sigma'}}
}
{}$$
}
\end{block}
\begin{block}{Axiome --- Realizează pasul computațional}
\onslide<4>{$$\reg{\Ss{\c{\Sif  {\terminal{true}} \Sthen c_1 \Selse c_2,\sigma}}{\c{c_1,\sigma}}}{}{}$$} 
\end{block}
\end{frame}
\end{section}

\begin{section}{O definiție tranzițională a semanticii limbajului IMP}
\begin{subsection}<handout:0|article:0>{Sintaxa și starea memoriei}
\begin{frame}<handout:0|article:0>{Sintaxa BNF a limbajului IMP}
\vspace{-5ex}\begin{syntaxBlock}{\AExp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid\terminal{!}\Id \Smid \AExp\iop \AExp}{}
\item[]\renewcommand{\defSort}{\BExp}
\syntax{\Bool \Smid \AExp\bop \AExp}{}
%\item[]\renewcommand{\defSort}{\Block}
%\syntax{\terminal{\{}\Stmt\terminal{\}} \Smid \terminal{\{}\terminal{\}}}{} 
\item[]\renewcommand{\defSort}{\Stmt}
\syntax{\Sskip \Smid \Id \terminal{:=} \AExp \Smid  \Stmt\terminal{;}\Stmt}{}
\syntaxCont{\Sif\BExp\Sthen \Block\Selse\Block \Smid \Swhile \BExp\Sdo \Block}{}
\item[]\renewcommand{\defSort}{\Pgm}
\syntax{\AExp \Smid \BExp \Smid \Stmt}{} 
\item[]\renewcommand{\defSort}{\Id}
\syntax{\mbox{locație de memorie / variabilă}}{} 
\\
\renewcommand{\defSort}{\Int}
\syntax{\mbox{număr întreg}}{}
\\
\renewcommand{\defSort}{\Bool}
\syntax{\Strue \mid \Sfalse}{}
\\
\renewcommand{\defSort}{\iop}
\syntax{\terminal{+} \Smid \terminal{-}\Smid \ldots}{}
\renewcommand{\defSort}{\bop}
\syntax{\terminal{=} \Smid \terminal{<}\Smid \ldots}{}
%\syntaxCont{\terminal{and} \Smid \terminal{or}\Smid \ldots}{}
\end{itemize}
}
\end{syntaxBlock}
\end{frame}

\begin{frame}<handout:0|article:0>{Starea memoriei}
\begin{block}{}
Starea memoriei unui program IMP la un moment dat este dată de valorile deținute în acel moment de variabilele declarate de program.

\structure{Matematic:} o funcție \alert{parțială} $s : \Id \xrightarrow{\circ}\SInt$ de domeniu finit.
\end{block}
\begin{block}{Notații}
\begin{itemize}
\item Descrierea funcției prin enumerare:
$s = \{ x \mapsto 10, sum \mapsto 0\}$
\item Funcția vidă $\bottom$, nedefinită pentru nici o variabilă
\item Obținerea valorii unei variabile: $s(x)$
\item Suprascrierea valorii unei variabile:

$$s[l\mapsto n] (l') = \left\{\begin{array}{r@{\mbox{, dacă }}l}
s	(l') & l' \neq l \\
n & l' = l
\end{array}
\right.$$
\end{itemize}
\end{block}
\end{frame}

\end{subsection}
\begin{subsection}{Reguli de deducție}
\begin{frame}{Expresii aritmetice}
\begin{itemize}
\item Un întreg este valoare --- nu poate fi redex, deci nu avem regulă

\hfill Configurația $\c{n,\sigma}$ este \structure{finală}\hfill\; 
%\item[] {\color{black!10}$\reg[Int]{\Ss{\c{i,\sigma}}{\c{i,\sigma}}}{}{}$}
\vitem[] $\reg[Loc]{\Ss{\c{\terminal{!} x,\sigma}}{\c{n, \sigma}}}{}{n = \sigma(x)}$
\vitem Ordine nespecificată de evaluare a argumentelor
\vitem[] $\reg[OpS]{\Ss{\c{e_1 \mathrel{o} e_2,\sigma}}{\c{e_1' \mathrel{o} e_2,\sigma'}}}{\Ss{\c{e_1,\sigma}}{\c{e_1',\sigma'}}}{}$
\vitem[] $\reg[OpR]{\Ss{\c{e_1 \mathrel{o} e_2,\sigma}}{\c{e_1 \mathrel{o} e_2',\sigma'}}}{\Ss{\c{e_2,\sigma}}{\c{e_2',\sigma'}}}{}$
\vitem Axioma efectuează operația din domeniu 
\vitem[] $\reg[Op]{\Ss{\c{n_1 \mathrel{o} n_2,\sigma}}{\c{v,\sigma}}}{}{v = n_1 \mathrel{o} n_2}$
\end{itemize}
\end{frame}
%\begin{frame}{Semantica SOS a lui IMP}
%{Ordine de evaluare. Împărțire}
%\begin{block}{Semantica împărțirii} 
%Evaluăm al doilea argument, și dacă e diferit de 0, atunci evaluăm si primul argument și apoi împărțirea.
%\end{block}
%\begin{itemize}
%\item[] $\reg{\Ss{\c{a_1 / a_2,\sigma}}{\c{a_1 / a_2',\sigma}}}{\Ss{\c{a_2,\sigma}}{\c{a_2',\sigma}}}{}$
%\vitem[] $\reg{\Ss{\c{a_1 / i_2,\sigma}}{\c{a_1' / i_2,\sigma}}}{\Ss{\c{a_1,\sigma}}{\c{a_1',\sigma}}}{i_2 \neq 0}$
%\vitem Evaluarea argumentelor de la dreapta la stânga
%\vitem[] $\reg[Div]{\Ss{\c{i_1 / i_2,\sigma}}{\c{i,\sigma}}}{}{i_2\neq 9, i = i_1 / i_2}$
%\end{itemize}
%\end{frame}
%\begin{frame}{Semantica SOS a lui IMP}
%{Expresii Booleene. Constante și operatorul de comparație.}
%\begin{itemize}
%\item Constantele Booleene sunt valori --- nu pot fi redex
%\vitem[] $\reg{\Ss{\c{a_1 \terminal{<=} a_2,\sigma}}{\c{a_1' \terminal{<=} a_2,\sigma}}}{\Ss{\c{a_1,\sigma}}{\c{a_1',\sigma}}}{}$\hfill$\reg{\Ss{\c{a_1 \terminal{<=} a_2,\sigma}}{\c{a_1 \terminal{<=} a_2',\sigma}}}{\Ss{\c{a_2,\sigma}}{\c{a_2',\sigma}}}{}$
%\vitem[] $\reg[Leq-false]{\Ss{\c{i_1 \terminal{<=} i_2,\sigma}}{\c{\terminal{false},\sigma}}}{}{i_1 > i_2}$
%\vitem[] $\reg[Leq-true]{\Ss{\c{i_1 \terminal{<=} i_2,\sigma}}{\c{\terminal{true},\sigma}}}{}{i_1 \leq i_2}$
%\end{itemize}
%\end{frame}
%\begin{frame}{Semantica SOS a lui IMP}
%{Expresii Booleene. Negația logică}
%\begin{itemize}
%\item[] $\reg{\Ss{\c{\terminal{!} a,\sigma}}{\c{\terminal{!} a',\sigma}}}{\Ss{\c{a,\sigma}}{\c{a',\sigma}}}{}$
%\vitem[] $\reg[!-true]{\Ss{\c{\terminal{!} \terminal{true},\sigma}}{\c{\terminal{false},\sigma}}}{}{}$
%\vitem[] $\reg[!-false]{\Ss{\c{\terminal{!} \terminal{false},\sigma}}{\c{\terminal{true},\sigma}}}{}{}$
%\end{itemize}
%\end{frame}
%\begin{frame}{Semantica SOS a lui IMP}
%{Expresii Booleene. Și-ul logic}
%\begin{itemize}
%\item[] $\reg{\Ss{\c{b_1 \terminal{\&\&} b_2,\sigma}}{\c{b_1' \terminal{\&\&} b_2,\sigma}}}{\Ss{\c{b_1,\sigma}}{\c{b_1',\sigma}}}{}$
%\vitem[] $\reg[\&\&-false]{\Ss{\c{\terminal{false}\; \terminal{\&\&} b_2,\sigma}}{\c{\terminal{false},\sigma}}}{}{}$
%\vitem[] $\reg[\&\&-true]{\Ss{\c{\terminal{true}\; \terminal{\&\&} b_2,\sigma}}{\c{b_2,\sigma}}}{}{}$
%\end{itemize}
%\end{frame}
\begin{frame}{Compunerea secvențială}
\begin{itemize}
\item $\terminal{skip}$ este „valoarea” comenzilor — $\c{\terminal{skip},\sigma}$ e configurație finală
\vitem[] $\reg[SeqS]{\Ss{\c{c_1 \terminal{;} c_2},\sigma}{\c{c_1' \terminal{;} c_2,\sigma'}}}{\Ss{\c{c_1,\sigma}}{\c{c_1',\sigma'}}}{}$
\vitem[] $\reg[Seq]{\Ss{\c{\terminal{skip} \terminal{;} s_2,\sigma}}{\c{s_2,\sigma}}}{}{}$
\end{itemize}
\end{frame}

\begin{frame}
{Atribuirea}
\begin{itemize}
\item[] $\reg[AtribD]{\Ss{\c{x \terminal{:=} e ,\sigma}}{\c{x \terminal{:=} e' ,\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$
\vitem[] $\reg[Atrib]{\Ss{\c{x \terminal{:=} n,\sigma}}{\c{\terminal{skip},\sigma'}}}{}{\sigma'=\sigma[x \mapsto n]}$
\end{itemize}
\end{frame}

\begin{frame}{Instrucțiunea condițională}
\begin{itemize}
\item[] 
$\reg[IfS]{
 \Ss{\c{\Sif {b} \Sthen c_1 \Selse c_2,\sigma}}{\c{\Sif  {b'} \Sthen c_1 \Selse c_2,\sigma'}}
}{
  \Ss{\c{b,\sigma}}{\c{b',\sigma'}}
}
{}$
\vitem[]
$\reg[IfTrue]{\Ss{\c{\Sif  {\terminal{true}} \Sthen c_1 \Selse c_2,\sigma}}{\c{c_1,\sigma}}}{}{}$ 
\vitem[]
$\reg[IfFalse]{\Ss{\c{\Sif {\terminal{false}} \Sthen c_1 \Selse c_2,\sigma}}{\c{c_2,\sigma}}}{}{}$ 

\end{itemize}
\end{frame}

\begin{frame}{Instrucțiunea de ciclare}
$\reg[While]{
 \Ss{\c{\Swhile {b} \Sdo c,\sigma}}{\c{\begin{array}[t]{lll}\Sif {b}&\Sthen &(c\terminal{;} {\Swhile {b} \Sdo c})\\& \Selse & {\terminal{skip}}\end{array},\sigma}}
}{}
{}$\end{frame}

\end{subsection}

\begin{subsection}{Execuția ca demonstrație}
\renewcommand{\bot}{\emptyset}
\begin{frame}{Demonstrarea unui pas}

\begin{itemize}
\item Fiecare pas de tranziție este o demonstrație alcătuită din mai multe reguli structurale și având la vârf o axiomă

\vitem O execuție este un lanț de tranziții 
\end{itemize}
\end{frame}

\begin{frame}
{Execuție pas cu pas}

$\begin{array}{lr}
\c{\alert{ i \terminal{:=} 3} \terminal{;} \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4,\bot}&\xrightarrow[\textsc{SeqS}]{\textsc{Atrib}}\\
\onslide<2->
\c{\alert{\terminal{skip} \terminal{;} \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4},\{i \mapsto 3\}}&\xrightarrow{\textsc{Seq}}\\
\onslide<3->
\c{\alert{\Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4 },\{i \mapsto 3\}}&\xrightarrow{\textsc{While}}\\
\onslide<4->
\c{\Sif 0 \terminal{<=} \alert{\terminal{!} i}\begin{array}[t]{ll} \Sthen& i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \terminal{;} \\& \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \\ \Selse &  \terminal{skip}\end{array},\{i \mapsto 3\}}&\xrightarrow[\textsc{IfS, OpD}]{\textsc{Loc}}\\
\onslide<5->
\c{\Sif \alert{0 \terminal{<=} 3}\begin{array}[t]{ll} \Sthen& i \terminal{:=} {\terminal{!} i} \terminal{-}  4 \terminal{;} \\& \Swhile 0 \terminal{<=}  {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \\ \Selse &\terminal{skip}\end{array},\{i \mapsto 3\}}&\xrightarrow[{\textsc{IfS}}]{\textsc{Op}}\\
\onslide<6->
\c{\alert{\Sif  {\Strue} \begin{array}[t]{ll} \Sthen&  i \terminal{:=} {\terminal{!}i} \terminal{-} 4 \terminal{;} \\ & \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=}  {\terminal{!} i} \terminal{-} 4\\ \Selse & \terminal{skip}\end{array}},\{i \mapsto 3\}}&\xrightarrow{\textsc{IfTrue}}\\
\onslide<7->
\c{ i \terminal{:=} \alert{ {\terminal{!} i}} \terminal{-} 4 \terminal{;} \Swhile 0 \terminal{<=}  {\terminal{!} i} \Sdo i \terminal{:=}  {\terminal{!} i} \terminal{-} 4 ,\{i \mapsto 3\}}&\xrightarrow[SeqS,AtribS,OpS]{\textsc{Loc}}\\
\end{array}$
\end{frame}
\begin{frame}{Execuție pas cu pas}{}

\vspace{-1.5ex}$\begin{array}{lr}
\c{i \terminal{:=} \alert{3 \terminal{-} 4} \terminal{;}  \Swhile 0 \terminal{<=}  {\terminal{!} i}\Sdo  i \terminal{:=}  {\terminal{!} i} \terminal{-} 4 ,\{i \mapsto 3\}}&\xrightarrow[\textsc{SeqS, AtribS}]{\textsc{Op}}\\
\onslide<2->
\c{\alert{ i \terminal{:=} -1} \terminal{;}  \Swhile 0 \terminal{<=}  {\terminal{!} i} \Sdo  i \terminal{:=}  {\terminal{!} i}  \terminal{-} 4 ,\{i \mapsto 3\}}&\xrightarrow[\textsc{SeqS}]{\textsc{Atrib}}\\
\onslide<3->
\c{\alert{\terminal{skip} \terminal{;} \Swhile 0 \terminal{<=}  {\terminal{!} i} \Sdo i \terminal{:=}  {\terminal{!} i}  \terminal{-} 4} ,\{ i \mapsto -1\}}&\xrightarrow{\textsc{Seq}}\\
\onslide<4->
\c{\alert{\Swhile (0 \terminal{<=}  {\terminal{!} i} )\Sdo i \terminal{:=}  {\terminal{!} i}  \terminal{-} 4 },\{i \mapsto -1\}}&\xrightarrow{\textsc{While}}\\
\onslide<5->
\c{\Sif 0 \terminal{<=} \alert{\terminal{!} i}\begin{array}[t]{ll} \Sthen& i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \terminal{;} \\& \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \\ \Selse &  \terminal{skip}\end{array},\{i \mapsto -1\}}&\xrightarrow[\textsc{IfS,OpD}]{\textsc{Loc}}\\
\onslide<6->
\c{\Sif \alert{0 \terminal{<=} -1}\begin{array}[t]{ll} \Sthen& i \terminal{:=} {\terminal{!} i} \terminal{-}  4 \terminal{;} \\& \Swhile 0 \terminal{<=}  {\terminal{!} i}\Sdo i \terminal{:=} {\terminal{!} i} \terminal{-} 4 \\ \Selse &\terminal{skip}\end{array},\{i \mapsto -1\}}&\xrightarrow[\textsc{IfS}]{\textsc{Op}}\\
\onslide<7->
\c{\alert{\Sif  {\Sfalse} \begin{array}[t]{ll} \Sthen&  i \terminal{:=} {\terminal{!}i} \terminal{-} 4 \terminal{;} \\ & \Swhile 0 \terminal{<=} {\terminal{!} i}\Sdo i \terminal{:=}  {\terminal{!} i} \terminal{-} 4\\ \Selse & \terminal{skip}\end{array}},\{i \mapsto -1\}}&\xrightarrow{\textsc{IfFalse}}\\
\onslide<8>
\c{\terminal{skip},\{i \mapsto -1\}}
\end{array}$
\end{frame}

\end{subsection}

\end{section}

\begin{section}{Demonstrații}
\begin{frame}{Configurații finale și configurații blocate}
Reprezintă configurații care nu se mai pot rescrie
\begin{block}{Configurații finale}
Sunt configurații care conțin valori ca fragmente de program:

\hfill $\c{n, \sigma}$\hfill $\c{\Strue, \sigma}$\hfill $\c{\Sfalse,\sigma}$\hfill $\c{\Sskip,\sigma}$\hfill\;
\end{block}

\begin{block}{Configurații blocate}
Sunt configurații care nu sunt finale dar care nu mai pot tranziționa

\hfill $\c{{3 + 5} * {\alert{\terminal{!} a}}, \{x\mapsto 2\}}$ \hfill $\c{\Sif 0 \Sthen c_1 \Selse c_2,\sigma}$ \hfill $\c{3 / 0, \sigma}$ \hfill\;
\end{block}
\end{frame}

\begin{frame}{Proprietăți demonstrabile}
\begin{block}{Determinism}  
Dacă $\c{p, \sigma}\longrightarrow \c{p_1, \sigma_1}$  și $\c{p, \sigma} \longrightarrow \c{p_2, \sigma_2}$, atunci $p_1 = p_2$ și $\sigma_1 = \sigma_2$
\end{block}

%\vfill
%\begin{block}{Conservarea tipurilor}
%Dacă $\c{p, \sigma}\longrightarrow \c{p', \sigma'}$ atunci $p'$ are același tip cu $p$.
%\end{block}

\vfill
\begin{block}{Expresiile nu modifică starea}
Dacă $p$ e expresie întreagă/booleană și $\c{p, \sigma}\longrightarrow \c{p', \sigma'}$ atunci $\sigma=\sigma'$
\end{block}
\end{frame}

\begin{frame}{Echivalența cu semantica naturală}
\begin{theorem}
Pentru toate configurațiile $\c{p,\sigma}$ și toate configurațiile finale $\c{v,\sigma'}$,
\[\S{\c{p,\sigma}}{\c{v,\sigma'}}  \iff \c{p,\sigma}\longrightarrow^\ast \c{v,\sigma'}\]
\end{theorem}

\onslide<2>
\begin{block}{Demonstrație (pași)}
\begin{enumerate}
\item $\S{\c{p,\sigma}}{\c{v,\sigma'}}  \implies \c{p,\sigma}\longrightarrow^\ast \c{v,\sigma'}$
\item $\Ss{\c{p,\sigma}}{\c{p_1,\sigma_1}}$ și $\S{\c{p_1,\sigma_1}}{\c{v,\sigma'}} \implies \S{\c{p,\sigma}}{\c{v,\sigma'}} $
\item $\c{p,\sigma} \longrightarrow^\ast{\c{v,\sigma'}} \implies \S{\c{p,\sigma}}{\c{v,\sigma'}}$
\end{enumerate}
\end{block}
\end{frame}

\end{section}


\end{document}
