\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}

\title[SLP---Funcții]{FUN-IMP}
\subtitle{Funcții}
\begin{document}
\maketitle

\begin{section}{Funcții/proceduri/subrutine}

 \lstset{
               basicstyle=\small,
               tabsize=2,
               %frame=tb,
               columns=flexible,
               mathescape=false,
	      upquote=true,
    }
\begin{frame}[fragile]{Exemple}{Adunare și incrementare ca funcții de ordinul I}
\begin{block}{C/C++/\ldots}
\begin{asciic}
int addition(int x, int y) { return x+y; }
int increment(int x) { return x+1; }
\end{asciic}
\end{block}

\begin{block}{OCaml}
\begin{asciiml}
let addition = fun (x,y) -> x + y
let increment = fun x -> x + 1
\end{asciiml}
\end{block}

\begin{block}{Javascript}
\begin{asciijs}
function addition(x,y) { return x + y; }
function increment(x) { return x + 1; }
\end{asciijs}
\end{block}

\end{frame}

\begin{frame}[fragile]{Exemple}{Stil funcțional}

\begin{description}
\item[Javascript]
\begin{asciijs}
addition = function (x) { return function(y) { return x+y; } }
increment = addition (1)
\end{asciijs}

\item[OCaml]
\begin{asciiml}
let adddition = fun x -> fun y -> x+y
let increment = addition 1
\end{asciiml}

\item[C++]
\begin{asciic}
#include<iostream>
using namespace std;
int main()
{
    auto plusFn = [] (int x) { return [x] (int y) {return x+y;};};
    auto inc = plusFn(1);
    cout << inc(3) << endl;
}
\end{asciic}
\end{description}
\end{frame}

\begin{frame}[fragile]{Exemple}{Instanțiere parțială a argumentelor în C++}
\begin{asciic}
#include <iostream>
#include <functional>
using namespace std;
using namespace std::placeholders;

int plusFn(int x,int y) {return x+y;}

int main()
{
    auto inc = bind(plusFn,_1,1);
    cout << inc(3) << endl;
}
\end{asciic}
\end{frame}


\begin{frame}[fragile]{Exemple}{Capturarea variabilelor din mediu în C++}
\begin{asciic}
#include <iostream>
#include <array>
#include <functional>
using namespace std;

int main() {
    array<function<int()>,11> funcs;
    for (auto i = 0; i < 11; i++) {
    	funcs[i] = [i]() {return i;};
    }
    for (auto f : funcs) {
    	cout << f() << endl;
    }
}
\end{asciic}
\end{frame}

\begin{frame}[fragile]{Exemple}{Capturarea variabilelor din mediu în C++}
\begin{asciic}
#include <iostream>
#include <array>
#include <functional>
using namespace std;

int main() {
    array<function<int()>,11> funcs;
    for (auto i = 0; i < 11; i++) {
    	funcs[i] = [&i]() {return i;};
    }
    for (auto f : funcs) {
    	cout << f() << endl;
    }
}
\end{asciic}
\end{frame}



\begin{frame}[fragile]{Exemple}{Capturarea variabilelor de mediu în Javascript}
\begin{asciijs}
var bar = function (x) { 
  return function() { var x = 5; return x; }; 
}
var f = bar(200);
f()
\end{asciijs}
\end{frame}
\end{section}

\begin{section}{FUN-IMP}
\begin{frame}[fragile]{Funcții + IMP = FUN-IMP}{Exemple}
\begin{asciiml}
fun (x:int) -> x+1

(fun (x:int) -> x+1) 7

fun (x:int) -> fun (y:int) -> x + y

(fun (x:int) -> fun (y:int) -> x + y) 1

fun (x:int->int) -> fun (y:int) -> x (x y)

(fun (x:int->int) -> fun (y:int) -> x (x y)) (fun (x:int) -> x+1)

((fun (x:int->int) -> fun (y:int) -> x (x y)) (fun (x:int) -> x+1)) 7
\end{asciiml}
\end{frame}


\begin{frame}{\only<beamer>{FUN-IMP}}{Sintaxă}
Extindem sintaxa limbajului IMP cu variabile, funcții și aplicația funcțiilor

\begin{description}
\item[Variabile] $\structure{x} \in \mathbb{X}$, unde $\mathbb{X} = \{\terminal{x}, \terminal{y}, \terminal{z}, \ldots\}$ disjunctă de mulțimea locațiilor de memorie $\mathbb{L}$
\vitem[Expresii]
\begin{syntaxBlock}{\Exp}
\alert{
\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid \structure{x}\Smid \Sfun (\structure{x}:\structure{T}) \rightarrow \Exp\Smid \Exp \mathrel{} \Exp}{}
}
\end{syntaxBlock}
\item[Tipuri]\alert{
\begin{itemize}
\item[]\(\structure{T} ::= {\color{black}\Sint} \Smid {\color{black}\Sbool} \Smid {\color{black}\Sunit} \Smid {\color{black}\structure{T} \rightarrow \structure{T}}\)
\item[]
\item[]\(\structure{T_{\it loc}} ::= {\color{black}\Sintref}\)
\end{itemize}}
\end{description} 
\end{frame}


\begin{frame}[fragile]{Sintaxă concretă}
\begin{itemize}
\item Aplicarea funcțiilor se grupează la stânga
\begin{asciiml}
(fun (x:int) -> fun (y:int) -> x + y) 3 5  
  = ((fun (x:int) -> fun (y:int) -> x + y) 3) 5 
\end{asciiml}
\item Tipul săgeată se grupează la dreapta
\begin{asciiml}
int -> int -> int  = int -> (int -> int) 
\end{asciiml}
\item $\Sfun$ se extinde cât de mult posibil la dreapta
\begin{asciiml}
fun (x:unit) -> x ; x   = fun (x:unit) -> (x ; x)
\end{asciiml}
\end{itemize}
\end{frame}

\end{section}


\begin{section}{Domeniul de vizibilitate al variabilelor}

\begin{frame}[fragile]{Domeniul de vizibilitate al variabilelor}{C\#}
\begin{asciics}
class P {
    public static void Main() {
        int i = 7 ;
        System.Console.WriteLine(i);
        {
          System.Console.WriteLine(i);
          int i = 13 ;
          System.Console.WriteLine(i);
        }
        System.Console.WriteLine(i);
    }
}
\end{asciics}
\end{frame}

\begin{frame}[fragile]{Domeniul de vizibilitate al variabilelor}{C++}
\begin{asciics}
#include <iostream>
using namespace std;
int main()  {
  int i = 7;
  cout << i << endl;
  {
     cout << i << endl;
     int i = 13;
     cout << i << endl;
  }
  cout <<i << endl;
}
\end{asciics}
\end{frame}



\begin{frame}{Legare}
\begin{block}{ $\Sfun (x:T) \rightarrow e$}
\begin{itemize}
\item \structure{$x$} se numește parametru formal / variabilă de legare
\item \structure{$e$} se numește corpul funcției / \structure{domeniul} legării lui $x$
\item Orice apariție a lui $x$ în $e$ ({\small \color{gray}care nu este parametru formal al altei funcții
 și nu este în corpul unei funcții $\Sfun (x:T') \rightarrow e'$ cu același parametru formal $x$})
\begin{itemize}
\item se referă la parametrul formal $x$ al funcției definită mai sus 
\item și se numește \structure{legată} de acesta.
\end{itemize}
%\[\lambda \structure<2->{x}.\alert<3>{y} * \lambda \structure<2->{y}. \structure<2->{x} + \structure<2->{y}\]
%\item O variabilă este legată de variabila de legare cea mai apropiată
%
%\hfill\(\lambda x . \lambda \structure<2->{x} . \structure<2->{x}\)\hfill\;
%\item Aparițiile nelegate se numesc \alert{libere}
\item Vizibilitatea variabilei de legare este limitată strict la definiția funcției
\begin{itemize}
 \item În afara definiției funcției, nu contează numele variabilei de legare
  \item Matematic vorbind, $f(x) = x + 1$ e același lucru cu $f(y) = y + 1$.
\end{itemize}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{$\alpha$-echivalență}
\begin{block}{Definiție intuitivă}
\begin{itemize}
\item Variabila de legare $\alert{x}$ din definiția $\Sfun (\alert{x}:T) \rightarrow e$ poate fi redenumită împreună cu toate aparițiile legate de ea (din $e$).

\item Procesul de redenumire a argumentului formal al unei definiții de funcție se numește 
\structure{$\alpha$-conversie}.

\item$\alpha$-conversia determină o relație de echivalență numită \structure{$\alpha$-echivalență}.
\[\Sfun (\alert{x}:{\Sint})\rightarrow \alert{x} + y \equiv_\alpha {\Sfun (\alert{z}:{\Sint})\rightarrow \alert{z} + y} \not \equiv_\alpha
{\Sfun (\alert{y}:{\Sint})\rightarrow \alert{y} + \alert{y}}
\]\end{itemize}
\end{block}
\end{frame}



\begin{frame}{Apariție liberă a unei variabile}
\begin{block}{Apariție \alert{liberă}/\structure{legată}}
O apariție a variabilei $x$ în expresia $e$ este \alert{liberă} dacă nu este în corpul  nici unei definiții de funcție $fun (x:T) \rightarrow \ldots$.

Orice altă apariție a lui $x$ este \structure{legată} de  cea mai apropiată  declarație $\Sfun (x:T) \rightarrow \ldots$ care o conține.
\end{block}

\begin{block}{Exemple}
\begin{itemize}
\item 17
\item $\alert{x} + \alert{y}$
\item $\Sfun (\structure{x}:{\Sint}) \rightarrow \structure{x} + 2$
\item $\Sfun (\structure{x}:{\Sint}) \rightarrow \structure{x} + \alert{z}$
\item $\Sif \alert{y} \Sthen 2 + \alert{x} \Selse (\Sfun (\structure{x}:{\Sint}) \rightarrow \structure{x} + 2)\;\alert{z}$
\item \(\Sfun (x:{\Sunit}) \rightarrow {\Sfun (\structure{x}:{\Sint}) \rightarrow \structure{x}}\)
\end{itemize}
\end{block}

\end{frame}

\begin{frame}{Variabile libere}{Definiție formală}
Funcția $\var$ care dă mulțimea variabilelor care apar libere într-o expresie e definită recursiv pe structura expresiilor:
\begin{itemize}
\item \structure{$\var(x) = \{x\}$}
\item \structure{$\var(\Sfun (x:T) \rightarrow  e) = \var(e) \setminus \{x\}$}
\item \structure{$\var(e_1 \terminal{} e_2) = \var(e_1) \cup \var(e_2)$}
\item $\var(n) = \var(b) = \var(l) = \var(\Sskip) = \var(\terminal{!} l)  =\emptyset$
\item $\var(e_1 \mathrel{o} e_2) = \var(e_1) \cup \var(e_2)$, $o\in \{+,\leq\}$
\item $\var(\Sif e_b \Sthen e_1 \Selse e_2) = \var(e_b) \cup\var(e_1) \cup\var(e_2)$
\item $\var(l \terminal{:=} e) = \var(e)$
\item $\var(e_1 \terminal{;} e_2) = \var(e_1) \cup \var(e_2)$
\item $\var(\Swhile e_b \Sdo e \Sdone) = \var(e_b) \cup \var(e)$
\end{itemize}
\end{frame}

\end{section}
\begin{section}{Evaluarea funcțiilor}
\begin{frame}{Evaluarea funcțiilor ca substituție}
\begin{itemize}
\item Dată fiind $f : \mathbb{Z} \longrightarrow \mathbb{Z}$, $f(x) = x * x$, simplificăm  $f(y+5)$  înlocuind în definiția funcției $f$ variabila $x$ cu valoarea dată $y+5$
\[f(y + 5) = (y + 5) * (y + 5)\] 
\vitem Folosind ideea de substituție, $f(y + 5) = (x * x)[(y + 5) / x]$
\item Unde $e[e' / x]$ se definește \alert{intuitiv} ca fiind expresia $e$ în care aparițiile libere ale lui $x$ se înlocuiesc cu $e'$.
\end{itemize}
\end{frame}

\begin{subsection}{Substituție}
\begin{frame}{\only<beamer|handout>{Substituție}}{Exemple}
\begin{block}{Definiția intuitivă a substituției $\alert{\substapp{e}{\subst{\substpair{e'}{x}}}}$}
Se obține prin înlocuirea cu $e'$ a tuturor aparițiilor libere ale lui $x$ în $e$
\end{block}

\vfill
\begin{itemize}
\item $\substapp{(\Sfun (x:{\Sint})\rightarrow x + y)}{\subst{\substpair{4}{y}}}\only<2->{={\Sfun (x:{\Sint})\rightarrow x + 4}}$
\item<2-> $\substapp{(\Sfun (x:{\Sint})\rightarrow x + y)}{\subst{\substpair{4}{x}}}\only<3->{={\Sfun (x:{\Sint})\rightarrow x + y}}$
\begin{itemize}
\item<3-> Deoarece $x$ nu apare liber
\end{itemize}
\item<3-> $\substapp{(\Sfun (x:{\Sint})\rightarrow x + y)}{\subst{\substpair{x}{y}}}\only<4->{\not={\Sfun (\structure{x}:{\Sint})\rightarrow  \structure{x} + \alert{x}}}$
\begin{itemize}
\item<4-> Deoarece variabila $\alert{x}$ ar fi \structure{capturată} (incorect) de operatorul de legare.
\end{itemize}
\item<5-> $\substapp{(\Sfun (x:{\Sint})\rightarrow x + y)}{\subst{\substpair{x}{y}}} \equiv_\alpha \substapp{(\Sfun (z:{\Sint})\rightarrow z + y)}{\subst{\substpair{x}{y}}} = {\Sfun (z:{\Sint})\rightarrow z + x}$
\end{itemize}
\end{frame}


\begin{frame}{Substituție simultană}
\begin{block}{Definiție}
O substituție este o funcție parțială de domeniu finit $\sigma : \mathbb{X} \stackrel{\circ}{\rightarrow} \mathbb{E}$ care asociază expresii variabilelor.
\end{block}

\begin{block}{Notații}
\begin{itemize}
\item  
$\sigma = \subst{\substpair{e_1}{x_1}, \substpair{e_2}{x_2}, \ldots, \substpair{e_n}{x_n}}$ 

se citește $e_1$ înlocuiește pe $x_1$, ș.a.m.d 
\item $\Dom \sigma = \{x_1, x_2, \ldots, x_n\}$
\item $\Ran \sigma = \{e_1, e_2, \ldots, e_n\}$

\item $\substapp{e}{\sigma}$ --- expresia obținută în urma aplicării substituției $\sigma$ expresiei $e$
\end{itemize}
\end{block}

\end{frame}

\begin{frame}{Definiție formală (inductivă)}
\begin{itemize}
\item[] $\displaystyle\reg{\substapp{x}{\sigma} = \sigma(x)}{}{x \in \Dom \sigma}$ 
\item[]
 $\displaystyle\reg{\substapp{x}{\sigma} = x}{}{x \not\in \Dom \sigma}$
\vitem[] $\displaystyle\reg{\substapp{n}{\sigma} = n}{}{}$
 \hfill și la fel pentru $b$, $!l$, și $\Sskip$
\vitem[] $\displaystyle\reg{\substapp{(e_1\mathrel{} e_2)}{\sigma} = e_1'\mathrel{} e_2'}{\substapp{e_1}{\sigma} = e_1' \si \substapp{e_2}{\sigma} = e_2'}{}$  
\\La fel și pentru ceilalți constructori de limbaj, mai puțin $\Sfun$ 
%	\vitem[]  $\displaystyle\reg{(\Sfun (x:T) \rightarrow e)[e' / y] = \Sfun (x:T) \rightarrow e}{}{x = y}$ 
\vitem[] $\displaystyle\reg{\substapp{(\Sfun (x:T) \rightarrow e)}{\sigma} = \Sfun (x:T) \rightarrow e'}{\substapp{e}{\sigma} = e'}{x \not \in \Dom \sigma \cup \var(\Ran \sigma)}$
\end{itemize}

\onslide<2>\vfill\alert{Ce facem dacă $x \in \Dom \sigma \cup \var(\Ran \sigma)$?}
\end{frame}



\begin{frame}{Substituție}{Evitarea capturării variabilelor}
\( \displaystyle\reg{\substapp{(\Sfun (x:T) \rightarrow e)}{\sigma} = \Sfun (x':T) \rightarrow e'}{\substapp{e}{\sigma'} = e'}{\;}\)

\vspace{-6ex}\hfill$\begin{array}{l}x \in \Dom \sigma \cup \var(\Ran \sigma)\\x' \not\in \var(e)\cup\var(\Ran \sigma)
\\ \sigma' = \substcomp{\subst{\substpair{x'}{x}}}{\sigma}\end{array}$


\vfill Dacă $x$ apare liber în $\Ran \sigma$
\begin{itemize}
\item Alegem o variabilă \structure{nouă} $x'$ (care nu apare liberă în $e$ sau $\Ran \sigma$)
\item $e'$ se obține din e aplicând substituția obținută din $\sigma$ prin (re)definirea lui $x$ ca $x'$
\[\sigma'(y) = \left\{\begin{array}{r@{\mbox{, dacă }}l}\sigma(x)&y\neq x\\x'&y=x\end{array}\right.\]
\item Putem să-l redefinim pe $x$ în $\sigma'$ pentru că toate aparițiile libere ale lui $x$ în $e$ sunt legate de parametrul formal al funcției.
\end{itemize}
\end{frame}

\begin{frame}{Substituție}{Exemplu}
\begin{itemize}
\item[] $\substapp{(\Sfun (y:{\Sint}) \rightarrow (\Sfun (y:{\Sint}) \rightarrow x + y)\; y)}{\subst{\substpair{y+2}{x}}}$
\onslide<2>
\item[=] $\Sfun (y':{\Sint}) \rightarrow (\substapp{((\Sfun (y:{\Sint}) \rightarrow x + y)\; y)}{\subst{\substpair{y'}{y},\substpair{y+2}{x}}})$
\item[=] $\Sfun (y':{\Sint}) \rightarrow$

\hfill $(\substapp{(\Sfun (y:{\Sint}) \rightarrow x + y)}{\subst{\substpair{y'}{y},\substpair{y+2}{x}}})\; (\substapp{y}{\subst{\substpair{y'}{y},\substpair{y+2}{x}}})$
\item[=] $\Sfun (y':{\Sint}) \rightarrow (\Sfun (y'':{\Sint}) \rightarrow (\substapp{(x + y)}{\subst{\substpair{y''}{y},\substpair{y+2}{x}}}))\; y'$
\item[=] $\Sfun (y':{\Sint}) \rightarrow $

\hfill$(\Sfun (y'':{\Sint}) \rightarrow (\substapp{x}{\subst{\substpair{y''}{y},\substpair{y+2}{x}}}) + (\substapp{y}{\subst{\substpair{y''}{y},\substpair{y+2}{x}}}))\; y'$
\item[=] $\Sfun (y':{\Sint}) \rightarrow (\Sfun (y'':{\Sint}) \rightarrow ((y+2) + y'')\; y'$
\end{itemize}
\end{frame}

\end{subsection}


\begin{subsection}{$\alpha$-echivalență}

\begin{frame}{$\alpha$-echivalență}{Definiție inductivă}
\begin{itemize}
\item[] $\displaystyle\reg[$\alpha$R]{e \equiv_\alpha e}{}{}$ \hfill \;\hfill  $\displaystyle\reg[$\alpha$S]{e' \equiv_\alpha e}{e \equiv_\alpha e'}{}$ \hfill\;\hfill $\displaystyle\reg[$\alpha$T]{e \equiv_\alpha e''}{e \equiv_\alpha e' \si e'  \equiv_\alpha e'' }{}$\hfill\;
\vitem[] $\displaystyle\reg[$\alpha@$]{e_1\mathrel{} e_2 \equiv_\alpha e_1'\mathrel{} e_2'}{e_1 \equiv_\alpha  e_1' \si e_2 \equiv_\alpha e_2'}{}$  
\hfill
$\displaystyle\reg[$\alpha:=$]{l\mathrel{:=} e \equiv_\alpha l\mathrel{:=} e'}{e \equiv_\alpha  e'}{}$

\vitem[]
La fel și pentru ceilalți constructori de limbaj, mai puțin $\Sfun$ 

\vitem[]
$\displaystyle\reg[$\alpha{\Sfun}$]{\Sfun (x:T) \rightarrow e \equiv_\alpha {\Sfun (x:T) \rightarrow e'}}{e \equiv_\alpha e'}{}$

\vitem[]
$\displaystyle\reg[$\alpha$conv]{\Sfun (x:T) \rightarrow e  \equiv_\alpha {\Sfun (y:T) \rightarrow (\substapp{e}{\subst{\substpair{y}{x}}})} }{}{y\not\in\var(e)}\hspace{-2em}$
\end{itemize}
\end{frame}



\begin{frame}{Proprietăți de compatibilitate}
\begin{block}{Compatibilitate cu substituția}
\[e_1 \equiv_\alpha e_1'  \mbox{ și } e_2 \equiv_\alpha e_2' \implies \substapp{e_1}{\subst{\substpair{e_2}{x}}} \equiv_\alpha \substapp{e_1'}{\subst{\substpair{e_2'}{x}}}\]
\end{block}

\begin{block}{Substituția e funcțională modulo $\alpha$-echivalență}
\[\substapp{e}{\sigma} = e_1 \mbox{ și } \substapp{e}{\sigma} = e_2 \implies e_1 \equiv_\alpha e_2\]
\end{block}


\vfill\begin{block}{Compatibilitate cu $\var$}
\[e \equiv_\alpha e'  \implies \var(e) = \var(e')\]
\end{block}
\end{frame}

\begin{frame}{Termeni FUN-IMP}
  \begin{block}{Definiție}
    Un termen FUN-IMP este o clasă de echivalență modulo $\equiv_\alpha$.
  \end{block}

\vfill
\begin{itemize}
\item Identificăm termenii obținuți prin redenumirea variabilelor legate
\item Simplificare: notăm clasa de echivalență prin oricare din reprezentanți.
\end{itemize}
\end{frame}

\end{subsection}

\begin{subsection}{Strategii de evaluare}
\begin{frame}[fragile]{Evaluarea funcțiilor}
Fie expresia $e$ dată de 
\begin{asciiml}
(fun (x : unit) -> l := 5 ; x ; x) (l := !l + 1)
\end{asciiml}

Care este starea finală corespunzătoare stării inițiale $\c{e,\{l\mapsto 0\}}$?
\[\c{e,\{l\mapsto 0\}} \longrightarrow^\ast \c{\Sskip, \{l\mapsto \alert{???}\}}\]

\end{frame}



\begin{frame}{Evaluare strictă (Cam toate limbajele care au efecte laterale)}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție
$\Sfun (x : T) \rightarrow e$
\item Apoi reducem $e_2$ până la o valoare $v$
\item Apoi reducem $(\Sfun (x : T) \rightarrow e)\mathrel{}v$ la $\substapp{e}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}

\onslide<2>
\[\begin{array}{ll}
& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := 0 + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) \Sskip, \{l \mapsto 1\}} \\
\rightarrow& \c{l := 5 ; \Sskip ; \Sskip, \{l \mapsto 1\}} \\
\rightarrow& \c{\Sskip ; \Sskip ; \Sskip, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; \Sskip, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 5\}} \\
\end{array}\]

\end{frame}


\begin{frame}{Evaluare non-strictă (Limbaje pur funcționale)} 
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție $\Sfun (x : T) \rightarrow e$
\item Apoi reducem $(\Sfun (x : T) \rightarrow e) \mathrel{}e_2$ la $\substapp{e}{\subst{\substpair{e_2}{x}}}$
\end{itemize}
\end{block}

\onslide<2>\hfill $\begin{array}{ll}
& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{l := 5 ; l := !l + 1 ; l := !l + 1, \{l \mapsto 0\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 5 + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 6 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 6 + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 7, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 7\}}
\end{array}$ \hfill\;

\end{frame}

\begin{frame}{Evaluare leneșă}{Implementări ale limbajelor pure gen Haskell}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reduc $e_1$ până la o funcție
$\Sfun (x : T) \rightarrow e$
\item Apoi reduc corpul funcției \structure{e} până la un $e'$ care are nevoie de $x$
\item Apoi reduc $e_2$ până la o valoare $v$
\item Apo reduc $(\Sfun (x : T) \rightarrow e')\mathrel{} v$ la $\substapp{e'}{\subst{\substpair{v}{x}}}$

\end{itemize}
\end{block}
\onslide<2>\hfill $\begin{array}{ll}
& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow \Sskip ; x ; x) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow x ; x) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow x ; x) (l := 5 + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow x ; x) (l := 6), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow x ; x) \Sskip, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip ; \Sskip, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 6\}} \\
\end{array}$ \hfill\;

\end{frame}


\begin{frame}{Evaluare nerestricționată}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem fie $e_1$ fie $e_2$
\item Putem reduce corpurile funcțiilor
\item Oricând avem  $(\Sfun (x : T) \rightarrow e') e''$, o putem (sau nu)
reduce la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\end{itemize} 
\end{block}
\end{frame}

\begin{frame}{Evaluare „normală“}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem mereu cel mai din stânga redex din cele de mai sus
\item Reducem $(\Sfun (x : T) \rightarrow e') e''$ la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\item Reducem $e_1$ (putem reduce și corpurile funcțiilor)
\item Dacă $e_1\not\rightarrow$, reducem $e_2$
\end{itemize} 
\end{block}

\onslide<2>\hfill {\small$\begin{array}{ll}
& \c{(fun (x : unit) \rightarrow l := 5 ; x ; x) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow \Sskip ; x ; x) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow \Sskip ; x ; x) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(fun (x : unit) \rightarrow x ; x) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 5 + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 6 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 6 + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 7, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 7\}}
\end{array}$} \hfill\;
\end{frame}


\end{subsection}

\begin{subsection}{Reguli de reducție}


\begin{frame}{Evaluare strictă}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție
$\Sfun (x : T) \rightarrow e$
\item Apoi reducem $e_2$ până la o valoare $v$
\item Apoi reducem $(\Sfun (x : T) \rightarrow e)\mathrel{}v$ la $\substapp{e}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[S@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[S@D]{\Ss{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}e_2,s}}{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}e_2',s'}}}{\Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\item[]$\reg[S@]{\Ss{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}v_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{v_2}{x}}}}$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}{Evaluare non-strictă} 
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție $\Sfun (x : T) \rightarrow e$
\item Apoi reducem $(\Sfun (x : T) \rightarrow e) \mathrel{}e_2$ la $\substapp{e}{\subst{\substpair{e_2}{x}}}$
\end{itemize}
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[NS@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[NS@]{\Ss{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Evaluare nerestricționată}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem fie $e_1$ fie $e_2$
\item Putem reduce corpurile funcțiilor
\item Oricând avem  $(\Sfun (x : T) \rightarrow e') e''$, o putem (sau nu)
reduce la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\end{itemize} 
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[NR@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[NR@D]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1\mathrel{}e_2',s'}}}{\Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\item[]$\reg[NRfunD]{\Ss{\c{\Sfun (x:T) \rightarrow e,s}}{\c{\Sfun (x:T) \rightarrow e',s}}}{\Ss{\c{e,s}}{\c{e',s'}}}{}$
\item[]$\reg[NR@]{\Ss{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Evaluare „normală“}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem mereu cel mai din stânga redex din cele de mai sus
\item Reducem $(\Sfun (x : T) \rightarrow e') e''$ la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\item Reducem $e_1$ (putem reduce și corpurile funcțiilor)
\item Dacă $e_1\not\rightarrow$, reducem $e_2$
\end{itemize} 
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[Nor@]{\Ss{\c{(\Sfun (x:T) \rightarrow e_1)\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\item[]$\reg[Nor@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{e_1 \mbox{ nu e încă funcție}}$
\item[]$\reg[NorfunD]{\Ss{\c{\Sfun (x:T) \rightarrow e,s}}{\c{\Sfun (x:T) \rightarrow e',s}}}{\Ss{\c{e,s}}{\c{e',s'}}}{}$
\item[]$\reg[Nor@D]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1\mathrel{}e_2',s'}}}{\displaystyle \c{e_1,s}\not\rightarrow \si \Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}{Evaluare leneșă}{Implementări ale limbajelor pure gen Haskell}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reduc $e_1$ până la o funcție
$\Sfun (x : T) \rightarrow e$
\item Apoi reduc corpul funcției \structure{e} până la un $e'$ care are nevoie de $x$
\item Apoi reduc $e_2$ până la o valoare $v$
\item Apo reduc $(\Sfun (x : T) \rightarrow e')\mathrel{} v$ la $\substapp{e'}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}
\begin{block}{Reguli?}
E mai complicat decât pare, deoarece trebuie să ne dăm seama că $e'$ are nevoie de $x$.
\end{block}

\end{frame}

\begin{frame}[fragile]{Fibonacci în Haskell}
\begin{asciimaude}
fibs = 0:1:zipWith (+) fibs (tail fibs)
fib n = fibs !! n
\end{asciimaude}
\end{frame}

\begin{frame}[fragile]{Numere prime în Haskell}{Ciurul lui Eratostene}
\begin{asciimaude}
primes = let { sieve (x:xs) = x : sieve [n | n <- xs, rem n x > 0] } 
           in sieve [2..] 
\end{asciimaude}
\end{frame}

\end{subsection}

%
%\begin{subsection}{Implementare --- Reprezentare De Buijn}
%\end{subsection}
%
\end{section}

%
%\begin{section}{Semantică operațională contextuală}
%\begin{frame}{Contexte de evaluare}
%  \begin{itemize}
%    \item Găsirea redex-ului se aseamănă cu un algoritm de analiză sintactică
%    \item Putem înlocui regulile structurale cu reguli gramaticale
%  \end{itemize}\small
%    \[\structure{\text{Sintaxă:\hspace{1em}}} e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}\]
%
%    \medskip
%  \begin{tabular}{ll}
%    \structure{Reguli structurale} 
%    & 
%    \structure{Contexte de evaluare} 
%    \\[1ex]
%        \begin{tabular}[t]{l} 
%          $\displaystyle\frac{\langle e_1, \sigma \rangle\longrightarrow\langle e'_1, \sigma \rangle}{\langle e_1 \mathrel{op} e_2, \sigma \rangle\longrightarrow\langle e'_1 \mathrel{op} e_2, \sigma \rangle}$ 
%          \\[4ex]
%          $\displaystyle\frac{\langle e_2, \sigma \rangle\longrightarrow\langle e'_2, \sigma \rangle}{\langle n_1 \mathrel{op} e_2, \sigma \rangle\longrightarrow\langle n_1 \mathrel{op} e'_2, \sigma \rangle}$ 
%        \end{tabular}\hspace{4em}
%          &
%        $\begin{array}[t]{rcl} 
%          c & \mathrel{::=} &\blacksquare
%          \\[1ex]
%         &  \mid & c \mathrel{op} e  
%          \\[1ex]
%          & \mid & n \mathrel{op} c 
%        \end{array}$
%      \end{tabular}
%  \vfill\begin{block}{Instanțierea unui context $c$ cu expresia $e$}
%      \[c[e] = c[e/\blacksquare]\]
%    \end{block}
%\end{frame}
%
%
%\begin{frame}{Contexte de evaluare}{Exemple}
%  \begin{description}
%    \item[Sintaxă:] $e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}$
%    \item[Contexte:] $c \mathrel{::=} {{\blacksquare} \mid {c \mathrel{op} e} \mid {n \mathrel{op} c}}$
%  \end{description}
%
%  \vfill
%  \begin{block}{Exemple de contexte}
%    \begin{tabular}{l@{\extracolsep{4em}}l}
%        \structure{Corecte} & \structure{Greșite}
%        \\
%        $\blacksquare$ & $5$
%        \\
%        $3 * \blacksquare$ & $x + \blacksquare$
%        \\
%        $9 + 3 * (\blacksquare + 7)$ & $3 * 3 + 3 * (\blacksquare + 7)$
%      \end{tabular}
%    \end{block}
%
%      \vfill
%      \begin{block}{Exemple de contexte instanțiate}
%        \begin{itemize}
%          \item $\blacksquare[x + 1] = x + 1$
%          \item $(9 + 3 * (\blacksquare + 7))[x] = 9 + 3 * (x + 7)$
%          \item $(9 + 3 * (\blacksquare + 7))[5] = 9 + 3 * (5 + 7)$
%        \end{itemize}
%      \end{block}
%\end{frame}
%
%
%\begin{frame}{Semantica Operațională Contextuală}
%{\cites{Felleisen, 1992}}
%  \begin{block}{Un pas de execuție folosind contexte de evaluare}
%    \begin{itemize}
%      \item Descompune expresia în contextul $c$ și redex-ul $r$
%      \item Aplică o regulă operațională asupra lui $r$ obținând $e$
%      \item Pune $e$ în contextul inițial, obținând $c[e]$
%%      \item Regulile structurale înlocuite de o \structure{singură} regulă de reducție globală
%    \[\frac{\langle r,\sigma \rangle \longrightarrow \langle e,\sigma \rangle}
%      {\langle c[r],\sigma \rangle \longrightarrow \langle c[e],\sigma \rangle}
%    \]
%      \end{itemize}
%  \end{block}
%  \begin{block}{Semantica: definiții de contexte și reguli de reducție}
%    \begin{description}
%    \item[Contexte:]   $c \mathrel{::=} {{\blacksquare} \mid {c \mathrel{op} e} \mid {n \mathrel{op} c}}$
%      \hfill \structure{Sintaxă:\ \ }
%    $e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}$
%    \item[Reguli:] 
%      \begin{tabular}[t]{@{}l} 
%          $\langle l, \sigma\rangle \longrightarrow \langle n, \sigma \rangle \mbox{ \it dacă } n = \sigma(l)$
%          \\
%          $\langle n_1 \mathrel{op} n_2, \sigma\rangle \longrightarrow \langle n, \sigma \rangle \mbox{ \it dacă } n = n_1 \mathrel{op_{int}} n_2$
%        \end{tabular}
%    \end{description}
%  \end{block}
%\end{frame}
%
%\begin{frame}{Evaluare leneșă folosind Semantica Contextuală}{Idee de bază}
%\begin{block}{Contexte de evaluare pentru aplicație}
% \[\begin{array}{crl}
%c & \mathrel{::=} & {\blacksquare} \\
% & \mid & \ldots \\
% & \mid & c\; e\\
% & \mid & (\Sfun (x:T) \rightarrow c)\; e \\
% & \mid & (\Sfun (x:T) \rightarrow c[x])\; c 
%\end{array}
%\]
%\end{block}
%
%\begin{block}{Regulă de evaluare pentru aplicație}
% \[
%\Ss{\c{(\Sfun(x:T)\rightarrow c[x])\; v, s}}{\c{(\Sfun(x:T)\rightarrow c[v])\; v, s}}
%\]
%\end{block}
%
%
%\end{frame}
%
%
%\end{section}

%
%\begin{section}{Semantică de evaluare pentru FUN-IMP}
%
%\begin{frame}{\only<beamer|handout>{Semantică de evaluare pentru FUN-IMP}}
% Relație defnită inductiv, de forma 
%\[ \S{\c{e,\sigma}}{\c{v,\sigma'}}\]
%unde:
%\begin{itemize}
%\item $e$ și $v$ sunt termeni FUN-IMP \structure{închiși}, i.e., $\var(e) = \var(v) = \emptyset$
%\item $\sigma$ și $\sigma'$ sunt stări (funcții parțiale de la locații la numere întregi)
%\item $v$ este o valoare 
%\begin{syntaxBlock}{\structure{v}}
%\renewcommand{\syntaxKeyword}{}
%\syntax{\Int\Smid \Bool \Smid \Id \Smid \Sskip \Smid \lambda \structure{x} . \Exp}{}
%\end{syntaxBlock}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{Expresii}
%\begin{itemize}
%\item[] $\reg[val]{\S{\c{v,\sigma}}{\c{v,\sigma}}}{}{v \mbox{ valoare}}$
%
%\vitem[]
%$\reg[op]{\S{\c{e_1\mathrel{o} e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{n_1, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{n_2, \sigma_2}}}{v = n_1 \mathrel{o} n_2}$
%
%\vitem[]
%$\reg[if-true]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_1}}}{\S{\c{e_b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{e_1,\sigma'}}{\c{v, \sigma_1}}}{}$
%
%\vitem[]
%$\reg[if-false]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_b,\sigma}}{\c{\Sfalse, \sigma'}}\si \S{\c{e_2,\sigma'}}{\c{v, \sigma_2}}}{}$
%
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{Memorie și compunere secvențială}
%\begin{itemize}
%\item[]
%$\reg[!]{\S{\c{{\mathrel{!} e},\sigma}}{\c{n,\sigma'}}}{\S{\c{e,\sigma}}{\c{l,\sigma'}}}{l \mbox{ locație, cu $l\in Dom(\sigma')$ și $\sigma'(l)=n$}}$
%
%\vitem[]
%$\reg[asgn]{\S{\c{{e_1\mathrel{:=} e_2},\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{e_1,\sigma}}{\c{l,\sigma_1}} \si \S{\c{e_2,\sigma_1}}{\c{n,\sigma_2}}}{\sigma' = \sigma_2[ l \mapsto n]}$
%
%\vitem[]
%$\reg[seq]{\S{\c{e_1\mathrel{;} e_2,\sigma}}{\c{\Sskip,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{\Sskip, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{\Sskip, \sigma_2}}}{}$
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{While}
%
%\vfill
%$\reg{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'''}}}{\S{\c{b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{c,\sigma'}}{\c{\Sskip, \sigma''}}\si \S{\c{\Swhile b \Sdo c,\sigma''}}{\c{\Sskip,\sigma'''}}}{}$
%
%\hfill ({\sc while-true})
%
%\vfill
%$\reg[while-false]{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{b,\sigma}}{\c{\Sfalse, \sigma'}}}{}$
%
%\vfill
%
%\end{frame}
%
%\end{subsection}
%
%\begin{frame}{Putem/vrem să demonstrăm}
%
%\[ \Downarrow_n \neq \Downarrow_v \]
%\end{frame}
%
%\end{section}

\begin{section}{Tipuri în FUN-IMP}
\begin{frame}{Reguli pentru tipuri în FUN-IMP}{Pregătiri}
\begin{block}{Mediul de tipuri}
Extindem mediul de tipuri de la o funcție de la locații la tipuri referință
la o funcție care în plus dă și tipuri pentru variabile.


Formal $\Gamma = \Gamma_l \uplus \Gamma_v$ (reuniune disjunctă) unde
\begin{itemize}
\item    $\Gamma_l : \mathbb{L} \stackrel\circ\rightarrow T_{\it loc}$ asociază tipuri referință la locații
\item    $\Gamma_v : \mathbb{X} \stackrel\circ\rightarrow T$ asociază tipuri variabilelor
\end{itemize}

Notăm cu $\Gamma[x\mapsto T]$ mediul de tipuri care e definit la fel ca $\Gamma$ peste tot, mai puțin în $x$ unde este $T$.
\end{block}
\end{frame}

\begin{frame}{Reguli pentru tipuri}{Funcții}
\begin{itemize}
\item[] $\reg[tVar]{\tjud{x}{T}}{}{\Gamma(x) = T}$

\vitem[] 
$\displaystyle\reg[tFun]{\tjud{\Sfun (x : T) \rightarrow e}{T \rightarrow T'}}{\tjud[\Gamma']{e}{T'}}{\Gamma' = \Gamma[x\mapsto T]}$

\vitem[]
$\displaystyle\reg[tApp]{\tjud{e_1\; e_2}{T'}}{\tjud{e_1}{T \rightarrow T'} \si \tjud{e_2}{T}}{}$
\end{itemize}
\end{frame}

\begin{frame}{Exemplu}{}


\[\displaystyle\reg[tApp]{
  \tjud[]{{(\Sfun (x:{\Sint}) \rightarrow x + 2)\; 2}}{\Sint}
}{
  \tjud[]{\Sfun (x:{\Sint}) \rightarrow x + 2}{{\Sint} \rightarrow {\Sint}}
    \si 
    \reg[tInt]{
      \tjud[]{2}{{\Sint}}
    }{
      \done
    }{}
}{}\]

\onslide<2>
\[
  \reg[tFun]{
    \tjud[]{\Sfun (x:{\Sint}) \rightarrow x + 2}{{\Sint} \rightarrow {\Sint}}
  }{
    \reg[t+]{
      \tjud[x:{\Sint}]{x+2}{\Sint}
  }{
      \reg[tVar]{
        \tjud[x:{\Sint}]{x}{\Sint}
      }{
        \done
      }{} 
      \si 
      \reg[tInt]{
        \tjud[x:{\Sint}]{2}{\Sint}
      }{
        \done
      }{}
  }{} 
  }{}
\]

\end{frame}

\begin{frame}{Proprietăți ale sistemului de tipuri}
\begin{theorem}[Progres]
Dacă $e$ închisă și dacă $\tjud{e}{T}$ și $\Dom \Gamma \subseteq \Dom s$, atunci fie $e$ este valoare, fie există $e'$, $s'$ astfel încât 
$\c{e,s}\longrightarrow\c{e',s'}$.

\structure{Demonstrație: inducție structurală asupra lui $e$.}
\end{theorem}

\begin{theorem}[Conservarea tipului]
Dacă $e$ închisă și dacă $\tjud{e}{T}$, $\Dom \Gamma \subseteq \Dom s$ și 
$\c{e,s}\longrightarrow\c{e',s'}$, atunci $\tjud{e'}{T}$, $e'$ închisă și $\Dom \Gamma \subseteq \Dom s'$.

\structure{Demonstrație: inducție deductivă, folosind lema de mai jos.}
\end{theorem}

\begin{lemma}[Substituția conservă tipul]

Dacă $\tjud{e}{T}$ și $\tjud[{\Gamma[x\mapsto T]}]{e'}{T'}$, atunci
$\tjud{\substapp{e'}{\subst{\substpair{e}{x}}}}{T'}$.

\structure{Demonstrație: inducție deductivă asupra definiției substituției.} 
\end{lemma}

\end{frame}

\end{section}

\begin{section}{Definiții locale}
\begin{frame}[fragile]{Definiții locale de variabile}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid {\Slet \structure{x} = \Exp  \Sin \Exp}}{}
\end{itemize}
}
\end{syntaxBlock}

\vfill 
\begin{block}{Exemple}
\begin{minipage}[t]{.35\columnwidth}
\begin{asciiml}
let n = 10 in
  sum := 0 ;
  i := n ;
  while ! i > 0 do
     sum  := !sum + !i;
     i := !i - 1;
  done
\end{asciiml}
\end{minipage}
\hfill\begin{minipage}[t]{.55\columnwidth}
\begin{asciiml}
let x = 10 in
   x + (let x = 20 + x in 
          x + x)
\end{asciiml}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}{Definire prin funcții și aplicații}
\begin{block}{Semantica declarațiilor locale}
Idee: \(\Slet x = e_1 \Sin e_2\) se comportă ca \((\Sfun (x : T_{e_1}) \rightarrow e_2)\; e_1\)
\end{block}
\vfill
\begin{block}{Tipul asociat (regulă derivată)}
\[\reg[tLet]{\tjud{\Slet x = e_1 \Sin e_2}{T_2}}{\tjud{e_1}{T_1} \si \tjud[\Gamma']{e_2}{T_2}}{\Gamma' = \Gamma[x\mapsto T_1]}\]
\end{block}
\end{frame}

\begin{frame}{Evaluarea (strictă) a declarațiilor locale}{Reguli derivate}
\[\reg[letS]{\Ss{\c{\Slet x = e_1 \Sin e_2,s}}{\c{\Slet x = e_1' \Sin e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}\]

\[\reg[let]{\Ss{\c{\Slet x = v \Sin e_2,s}}{\c{\substapp{e_2}{\subst{\substpair{v}{x}}},s}}}{}{}\]
\end{frame}

\begin{frame}{$\alpha$-echivalență penrtu declarații locale}
\begin{itemize}
\item Operatorul $\Slet x = e_1 \Sin e_2$ este un operator de legare (derivat)
\begin{itemize}
\item Leagă variabila $x$ în termenul $e_2$  (dar nu și în $e_1$)
\item Ușor de observat din definiția lui $\Slet$ în funcție de $\Sfun$
\end{itemize}
\vitem $\var(\Slet x = e_1 \Sin e_2) = \var(e_1) \cup (\var(e_2) \setminus \{x\})$
\vitem $\reg[$\alpha$let]{\Slet x = e_1 \Sin e_2 \equiv_\alpha \Slet x' = e_1 \Sin e_2'}{}{}$

\hfill  {\it dacă}  $x'\not\in\var(e_2)$ 
și $e_2[x'/x] = e_2'$
\begin{itemize}
\item $\Slet x : {\Sint} = 10 \Sin
   x + (\Slet x : {\Sint} = 20 + x \Sin 
          x + x) \equiv_\alpha$\\$\Slet x : {\Sint} = 10 \Sin
   x + (\Slet y : {\Sint} = 20 + x \Sin 
          y + y)$
\end{itemize}
\end{itemize}
\end{frame}
\end{section}
\begin{section}{Definiții (locale) recursive}

\begin{frame}{Definiții recursive \only<2>{\alert{?}}}
\begin{block}{Întrebare: La ce se evaluează următorul program?}
\small
\[\Slet f = \Sfun (n:{\Sint})\rightarrow \Sif n \leq 0 \Sthen 0 \Selse n + \alert<2>{f} (n + -1) \Sin f\; 10\] 
\end{block}

\onslide<2>
\begin{alertblock}{Răspuns: La nimic}
Deoarece programul nu este închis: $f$ apare liberă în definiția lui $f$. 

Avem nevoie de un mecanism separat  pentru a putea defini funcții recursive.
\end{alertblock}

\end{frame}


\begin{frame}[fragile]{Ce este o funcție recursivă?}{Exemplu}
\begin{block}{Exemplu}
  Vrem o funcție ${\rm sum}$ de tip $\Sint \rightarrow \Sint$ astfel încât
 $\alert{\rm sum} \equiv  
  {\Sfun (n : {\Sint}) \rightarrow
    {\Sif n <= 0 \Sthen 0 \Selse n + \alert{\rm sum} (n + -1)}}$
\end{block}

\onslide<2->
\begin{block}{Funcție recursivă ca punct fix al unui operator}
\begin{asciiml}
let F =  fun (f : int -> int) -> 
  fun (n : int) -> if (n <= 0) then 0 else n + f (n + -1)
\end{asciiml}

Vrem ${\rm sum}$ astfel încât ${\rm sum} = F\; {\rm sum}\onslide<3-> = F\; (F\; {\rm sum}) = F\; (F\; (F\; {\rm sum})) = \ldots$
\end{block}

\end{frame}

\begin{frame}{Ce este o funcție recursivă?}
\begin{block}{Definiție (Funcție recursivă definită de un operator)}
Dat fiind un operator $F : t \rightarrow t$ ($t$ tip funcțional), funcția recursivă definită de $F$ este un (cel mai mic) punct fix al lui $F$, adică funcția $f$ cu cel mai mic domeniu care satisface $F(f) = f$.
\end{block} 

\begin{block}{Rezultat (Teorema de  punct fix a lui Kleene)}
Dacă \ldots \cites{Domeniul lui $F$ este o m. p.o. $\omega$-completă, și $F$ este $\omega$-continuă}, atunci cel mai mic punct fix al lui $F$ există și e dat de relația:

\[{\rm f} = \mathop{sup}_{n\in\mathbb{N}} F^n(\bot)\]
\end{block}


\end{frame}


\begin{frame}[fragile]{Definiții recursive}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid {\Sletrec \structure{x} : \structure{T} = \Exp  \Sin \Exp}}{}
\end{itemize}
}
\end{syntaxBlock}

\vfill
\begin{block}{Exemplu}
\begin{asciiml}
let rec sum : int -> int = 
  fun (n : int) ->
    if n <= 0 
    then 0 
    else n + sum (n + -1)
in sum 10 
\end{asciiml}
\end{block}
\end{frame}

\begin{frame}{Variabile libere, substituție și $\alpha$-echivalență}
\begin{itemize}
\item $\Sletrec x : T = e_1 \Sin e_2$ leagă variabila x atât în $e_1$ cât și în $e_2$
{\small
\(\Sletrec \structure{f} : {\Sint} \rightarrow {\Sint} = \Sfun (n:{\Sint})\rightarrow \Sif n \leq 0 \Sthen 0 \Selse n + \structure{f} (n + -1) \Sin \structure{f}\; 10\) 
}
\vitem $\var(\Sletrec x : T = e_1 \Sin e_2) = (\var(e_1) \cup \var(e_2)) \setminus \{x\}$

\vitem $\displaystyle\reg{(\Sletrec x : T = e_1 \Sin e_2)[e/y] = \Sletrec x : T = e_1' \Sin e_2'}{e_1[e/y] = e_1' \si e_2[e/y] = e_2'}{}$

\hfill dacă ${x\not\in \var(e)\cup \{ y\}}$

\vitem $\Sletrec x = e_1 \Sin e_2 \equiv_\alpha \Sletrec y = e_1' \Sin e_2'$

 \hfill {\it dacă} $y\not\in \var(e_1)\cup \var(e_2)$, $e_1[y/x] = e_1'$ și $e_2[y/x] = e_2'$ 
 
\end{itemize}
\end{frame}

\begin{frame}{Semantică $\Sletrec$}

\begin{block}{Regula de tipuri}
\[\reg[tLetRec]{\tjud{\Sletrec x : T = e_1 \Sin e_2}{T_2}}{\tjud[\Gamma']{e_1}{T}\si\tjud[\Gamma']{e_2}{T_2}}{\Gamma' = \Gamma[x\mapsto T]}
\]
\end{block}

\vfill
\begin{block}{Regula semantică}
\[\reg[letrec]{\!\Ss{\c{\Sletrec x\!:\!T = e_1 \Sin e_2,s}}{\c{e_2[\Sletrec x\!:\!T = e_1 \Sin e_1/x],s}}}{}{}\]
\end{block}
\end{frame}



\end{section}

\begin{section}{Implementare}
\begin{frame}{Posibilități de implementare a funcțiilor}
\begin{itemize}
\item Bazate pe substituție
  \begin{itemize}
    \item Mai aproape de definiția formală
    \item Dificil și potențial ineficient de implementat
  \end{itemize}
\vitem Bazate pe închideri (closures)
  \begin{itemize}
    \item Implementări eficiente
    \item Grad de flexibilitate ridicat
       \begin{itemize}
          \item De exemplu e ușor de implementat evaluarea leneșă cu închideri
       \end{itemize}
    \item O valoare de funcție înglobează și mediul în care aceasta e definită
  \end{itemize}
\end{itemize}
\end{frame}

%\begin{frame}{Eliminarea parametrilor formali}
%\begin{itemize}
%\item $\alpha$ echivalența ne spune că nu contează numele parametrului formal
%{\small
%\[\Sfun (\alert{x}:{\Sint}) \rightarrow \alert{x} + z \equiv_\alpha {\Sfun (\alert{y}:{\Sint}) \rightarrow \alert{y} + z} \not\equiv_\alpha {\Sfun (\alert{z}:{\Sint}) \rightarrow \alert{z} + \alert{z}}\]}
%\item Dar totuși, în implementarea substituției, numele contează
%  \begin{itemize}
%    \item Capturarea variabilelor introduce cea mai mare complexitate 
%  \end{itemize}
%
%\end{itemize}
%\end{frame}
\end{section}

\end{document}