\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../../tslides}


\title[PD---Funcții II]{FUN-IMP}
\subtitle{Tipuri și recursie}
\begin{document}
\maketitle

\begin{section}{Tipuri în FUN-IMP}
\begin{frame}{Reguli pentru tipuri în FUN-IMP}{Pregătiri}
\begin{block}{Mediul de tipuri}
Extindem mediul de tipuri de la o funcție de la locații la tipuri referință
la o funcție care în plus dă și tipuri pentru variabile.


Formal $\Gamma = \Gamma_l \uplus \Gamma_v$ (reuniune disjunctă) unde
\begin{itemize}
\item    $\Gamma_l : \mathbb{L} \stackrel\circ\rightarrow T_{\it loc}$ asociază tipuri referință la locații
\item    $\Gamma_v : \mathbb{X} \stackrel\circ\rightarrow T$ asociază tipuri variabilelor
\end{itemize}

Notăm cu $\Gamma[x\mapsto T]$ mediul de tipuri care e definit la fel ca $\Gamma$ peste tot, mai puțin în $x$ unde este $T$.
\end{block}
\end{frame}

\begin{frame}{Reguli pentru tipuri}{Funcții}
\begin{itemize}
\item[] $\reg[tVar]{\tjud{x}{T}}{}{\Gamma(x) = T}$

\vitem[] 
$\displaystyle\reg[tFun]{\tjud{\Sfun (x : T) \rightarrow e}{T \rightarrow T'}}{\tjud[\Gamma']{e}{T'}}{\Gamma' = \Gamma[x\mapsto T]}$

\vitem[]
$\displaystyle\reg[tApp]{\tjud{e_1\; e_2}{T'}}{\tjud{e_1}{T \rightarrow T'} \si \tjud{e_2}{T}}{}$
\end{itemize}
\end{frame}

\begin{frame}{Exemplu}{}


\[\displaystyle\reg[tApp]{
  \tjud[]{{(\Sfun (x:{\Sint}) \rightarrow x + 2)\; 2}}{\Sint}
}{
  \tjud[]{\Sfun (x:{\Sint}) \rightarrow x + 2}{{\Sint} \rightarrow {\Sint}}
    \si 
    \reg[tInt]{
      \tjud[]{2}{{\Sint}}
    }{
      \done
    }{}
}{}\]

\onslide<2>
\[
  \reg[tFun]{
    \tjud[]{\Sfun (x:{\Sint}) \rightarrow x + 2}{{\Sint} \rightarrow {\Sint}}
  }{
    \reg[t+]{
      \tjud[x:{\Sint}]{x+2}{\Sint}
  }{
      \reg[tVar]{
        \tjud[x:{\Sint}]{x}{\Sint}
      }{
        \done
      }{} 
      \si 
      \reg[tInt]{
        \tjud[x:{\Sint}]{2}{\Sint}
      }{
        \done
      }{}
  }{} 
  }{}
\]

\end{frame}

\begin{frame}{Proprietăți ale sistemului de tipuri}
\begin{theorem}[Progres]
Dacă $e$ închisă și dacă $\tjud{e}{T}$ și $\Dom \Gamma \subseteq \Dom s$, atunci fie $e$ este valoare, fie există $e'$, $s'$ astfel încât 
$\c{e,s}\longrightarrow\c{e',s'}$.

\structure{Demonstrație: inducție structurală asupra lui $e$.}
\end{theorem}

\begin{theorem}[Conservarea tipului]
Dacă $e$ închisă și dacă $\tjud{e}{T}$, $\Dom \Gamma \subseteq \Dom s$ și 
$\c{e,s}\longrightarrow\c{e',s'}$, atunci $\tjud{e'}{T}$, $e'$ închisă și $\Dom \Gamma \subseteq \Dom s'$.

\structure{Demonstrație: inducție deductivă, folosind lema de mai jos.}
\end{theorem}

\begin{lemma}[Substituția conservă tipul]

Dacă $\tjud{e}{T}$ și $\tjud[{\Gamma[x\mapsto T]}]{e'}{T'}$, atunci
$\tjud{\substapp{e'}{\subst{\substpair{e}{x}}}}{T'}$.

\structure{Demonstrație: inducție deductivă asupra definiției substituției.} 
\end{lemma}

\end{frame}

\end{section}

\begin{section}{Definiții locale}
\begin{frame}[fragile]{Definiții locale de variabile}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid {\Slet \structure{x} : \structure{T} = \Exp  \Sin \Exp}}{}
\end{itemize}
}
\end{syntaxBlock}

\vfill 
\begin{block}{Exemple}
\begin{minipage}[t]{.35\columnwidth}
\begin{asciiml}
let n : int = 10 in
  sum := 0 ;
  i := n ;
  while ! i > 0 do
     sum  := !sum + !i;
     i := !i - 1;
  done
\end{asciiml}
\end{minipage}
\hfill\begin{minipage}[t]{.55\columnwidth}
\begin{asciiml}
let x : int = 10 in
   x + (let x : int = 20 + x in 
          x + x)
\end{asciiml}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}{Definire prin funcții și aplicații}
\begin{block}{Semantica declarațiilor locale}
\[\Slet x : T = e_1 \Sin e_2  \stackrel{def}{=} (\Sfun (x : T) \rightarrow e_2)\; e_1\]
\end{block}
\vfill
\begin{block}{Tipul asociat (regulă derivată)}
\[\reg[tLet]{\tjud{\Slet x : T = e_1 \Sin e_2}{T_2}}{\tjud{e_1}{T} \si \tjud[\Gamma']{e_2}{T_2}}{\Gamma' = \Gamma[x\mapsto T]}\]
\end{block}
\end{frame}

\begin{frame}{Evaluarea (strictă) a declarațiilor locale}{Reguli derivate}
\[\reg[letS]{\Ss{\c{\Slet x : T = e_1 \Sin e_2,s}}{\c{\Slet x : T = e_1' \Sin e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}\]

\[\reg[let]{\Ss{\c{\Slet x : T = v \Sin e_2,s}}{\c{\substapp{e_2}{\subst{\substpair{v}{x}}},s}}}{}{}\]
\end{frame}

\begin{frame}{$\alpha$-echivalență penrtu declarații locale}
\begin{itemize}
\item Operatorul $\Slet x : T = e_1 \Sin e_2$ este un operator de legare (derivat)
\begin{itemize}
\item Leagă variabila $x$ în termenul $e_2$  (dar nu și în $e_1$)
\item Ușor de observat din definiția lui $\Slet$ în funcție de $\Sfun$
\end{itemize}
\vitem $\var(\Slet x : T = e_1 \Sin e_2) = \var(e_1) \cup (\var(e_2) \setminus \{x\})$
\vitem $\reg[$\alpha$let]{\Slet x : T = e_1 \Sin e_2 \equiv_\alpha \Slet x' : T = e_1 \Sin e_2'}{}{}$

\hfill  {\it dacă}  $x'\not\in\var(e_2)$ 
și $e_2[x'/x] = e_2'$
\begin{itemize}
\item $\Slet x : {\Sint} = 10 \Sin
   x + (\Slet x : {\Sint} = 20 + x \Sin 
          x + x) \equiv_\alpha$\\$\Slet x : {\Sint} = 10 \Sin
   x + (\Slet y : {\Sint} = 20 + x \Sin 
          y + y)$
\end{itemize}
\end{itemize}
\end{frame}
\end{section}
\begin{section}{Definiții (locale) recursive}

\begin{frame}{Definiții recursive \only<2>{\alert{?}}}
\begin{block}{Întrebare: La ce se evaluează următorul program?}
\small
\[\Slet f : {{\Sint}\rightarrow {\Sint}} = \Sfun (n:{\Sint})\rightarrow \Sif n \leq 0 \Sthen 0 \Selse n + \alert<2>{f} (n + -1) \Sin f\; 10\] 
\end{block}

\onslide<2>
\begin{alertblock}{Răspuns: La nimic}
Deoarece programul nu este închis: $f$ apare liberă în definiția lui $f$. 

Avem nevoie de un mecanism separat  pentru a putea defini funcții recursive.
\end{alertblock}

\end{frame}


\begin{frame}[fragile]{Ce este o funcție recursivă?}{Exemplu}
\begin{block}{Exemplu}
  Vrem o funcție ${\rm sum}$ de tip $\Sint \rightarrow \Sint$ astfel încât
 $\alert{\rm sum} \equiv  
  {\Sfun (n : {\Sint}) \rightarrow
    {\Sif n <= 0 \Sthen 0 \Selse n + \alert{\rm sum} (n + -1)}}$
\end{block}

\onslide<2->
\begin{block}{Funcție recursivă ca punct fix al unui operator}
\begin{asciiml}
let F : (int -> int) -> (int -> int) =  fun (f : int -> int) -> 
  fun (n : int) -> if (n <= 0) then 0 else n + f (n + -1)
\end{asciiml}

Vrem ${\rm sum}$ astfel încât ${\rm sum} = F\; {\rm sum}\onslide<3-> = F\; (F\; {\rm sum}) = F\; (F\; (F\; {\rm sum})) = \ldots$
\end{block}

\end{frame}

\begin{frame}{Ce este o funcție recursivă?}
\begin{block}{Definiție (Funcție recursivă definită de un operator)}
Dat fiind un operator $F : t \rightarrow t$ ($t$ tip funcțional), funcția recursivă definită de $F$ este un (cel mai mic) punct fix al lui $F$, adică funcția $f$ cu cel mai mic domeniu care satisface $F(f) = f$.
\end{block} 

\begin{block}{Rezultat (Teorema de  punct fix a lui Kleene)}
Dacă \ldots \cites{Domeniul lui $F$ este o m. p.o. $\omega$-completă, și $F$ este $\omega$-continuă}, atunci cel mai mic punct fix al lui $F$ există și e dat de relația:

\[{\rm f} = \mathop{sup}_{n\in\mathbb{N}} F^n(\bot)\]
\end{block}


\end{frame}


\begin{frame}[fragile]{Definiții recursive}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid {\Sletrec \structure{x} : \structure{T} = \Exp  \Sin \Exp}}{}
\end{itemize}
}
\end{syntaxBlock}

\vfill
\begin{block}{Exemplu}
\begin{asciiml}
let rec sum : int -> int = 
  fun (n : int) ->
    if n <= 0 
    then 0 
    else n + sum (n + -1)
in sum 10 
\end{asciiml}
\end{block}
\end{frame}

\begin{frame}{Variabile libere, substituție și $\alpha$-echivalență}
\begin{itemize}
\item $\Sletrec x = e_1 \Sin e_2$ leagă variabila x atât în $e_1$ cât și în $e_2$
{\small
\(\Sletrec \structure{f} : {\Sint} \rightarrow {\Sint} = \Sfun (n:{\Sint})\rightarrow \Sif n \leq 0 \Sthen 0 \Selse n + \structure{f} (n + -1) \Sin \structure{f}\; 10\) 
}
\vitem $\var(\Sletrec x : T = e_1 \Sin e_2) = (\var(e_1) \cup \var(e_2)) \setminus \{x\}$

\vitem $\displaystyle\reg{(\Sletrec x : T = e_1 \Sin e_2)[e/y] = \Sletrec x : T = e_1' \Sin e_2'}{e_1[e/y] = e_1' \si e_2[e/y] = e_2'}{}$

\hfill dacă ${x\not\in \var(e)\cup \{ y\}}$

\vitem $\Sletrec x = e_1 \Sin e_2 \equiv_\alpha \Sletrec y = e_1' \Sin e_2'$

 \hfill {\it dacă} $y\not\in \var(e_1)\cup \var(e_2)$, $e_1[y/x] = e_1'$ și $e_2[y/x] = e_2'$ 
 
\end{itemize}
\end{frame}

\begin{frame}{Semantică $\Sletrec$}

\begin{block}{Regula de tipuri}
\[\reg[tLetRec]{\tjud{\Sletrec x : T = e_1 \Sin e_2}{T_2}}{\tjud[\Gamma']{e_1}{T}\si\tjud[\Gamma']{e_2}{T_2}}{\Gamma' = \Gamma[x\mapsto T]}
\]
\end{block}

\vfill
\begin{block}{Regula semantică}
\[\reg[letrec]{\!\Ss{\c{\Sletrec x\!:\!T = e_1 \Sin e_2,s}}{\c{e_2[\Sletrec x\!:\!T = e_1 \Sin e_1/x],s}}}{}{}\]
\end{block}
\end{frame}



\end{section}

\begin{section}{Implementare}
\begin{frame}{Posibilități de implementare a funcțiilor}
\begin{itemize}
\item Bazate pe substituție
  \begin{itemize}
    \item Mai aproape de definiția formală
    \item Dificil și potențial ineficient de implementat
  \end{itemize}
\vitem Bazate pe închideri (closures)
  \begin{itemize}
    \item Implementări eficiente
    \item Grad de flexibilitate ridicat
       \begin{itemize}
          \item De exemplu e ușor de implementat evaluarea leneșă cu închideri
       \end{itemize}
    \item O valoare de funcție înglobează și mediul în care aceasta e definită
  \end{itemize}
\end{itemize}
\end{frame}

%\begin{frame}{Eliminarea parametrilor formali}
%\begin{itemize}
%\item $\alpha$ echivalența ne spune că nu contează numele parametrului formal
%{\small
%\[\Sfun (\alert{x}:{\Sint}) \rightarrow \alert{x} + z \equiv_\alpha {\Sfun (\alert{y}:{\Sint}) \rightarrow \alert{y} + z} \not\equiv_\alpha {\Sfun (\alert{z}:{\Sint}) \rightarrow \alert{z} + \alert{z}}\]}
%\item Dar totuși, în implementarea substituției, numele contează
%  \begin{itemize}
%    \item Capturarea variabilelor introduce cea mai mare complexitate 
%  \end{itemize}
%
%\end{itemize}
%\end{frame}
\end{section}

\end{document}