\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}
\usepackage{../tslides}

\title[SLP---Semantica evaluării]{Semantica Limbajelor de Programare}
\subtitle{Semantica naturală / a evaluării}
\begin{document}
\maketitle

%!TEX root = 04-semantica evaluarii.tex

\begin{frame}{Mașini abstracte}{Avantaje și dezavantaje}
\begin{block}{Puncte forte}
\begin{itemize}
\item Ușor (și eficient) de implementat
\item (Relativ) ușor de manipulat stivele de control și date
\item Foarte flexibilă --- limbajul stivelor fiind la alegerea celui ce o definește
\end{itemize}
\end{block}
\vfill
\begin{block}{Puncte slabe}
\begin{itemize}
\item Multe tranziții au doar scop sintactic, ne-computațional
\item Datorită îmbogățirii limbajului, multe configurații sunt irelevante 
\item Prea concretă si flexibilă, ceea ce îngreunează folosirea ei pentru raționamente formale
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Semantică operațională \structure{structurată (SOS)}}
{Concept (Plotkin, 1981) }

\begin{itemize}
\vitem Definiția sistemului de tranziție trebuie să reflecte structura limbajului
\item Tranzițiile pentru elemente compuse sa fie definite recursiv 
\begin{itemize}
\item în funcție de tranzițiile pe componente
\end{itemize}
\item Raționamente formale asupra sistemului prin inducție


\vitem Execuția ca demonstrație 
\item Controlul execuției este dat (intuitiv) de „firul deomnstrației“

\vitem Claritate prin abstractizare
\item Stivele de control și rezultate nu mai sunt necesare
\end{itemize}
\end{frame}

\begin{section}{Semantică naturală}
\begin{frame}{Semantica naturală / a evaluării}{Expresii aritmetice}
Definim recursiv graficul relației de evaluare ca mulțime de perechi $(e, s, n)$
\begin{itemize}
  \item $e$ --- expresie, $s$ --- stare a memorie, $n$ --- valoare întreagă
  \item Notăm $\S{\c{e,s}}{n}$ pentru a sugera ideea de funcție de evaluare
\end{itemize}

\vfill\begin{block}{Axiome și reguli}
\begin{itemize}
\item[] $\reg[int]{\S{\c{n,s}}{n}}{}{n \mbox{ întreg}}$

\item[]$\reg[loc]{\S{\c{{\mathrel{!} l},s}}{n}}{}{l \mbox{ locație, cu $l\in Dom(s)$ și $s(l)=n$}}$

\item[]$\reg[iop]{\S{\c{e_1\mathrel{o} e_2,s}}{n}}{\S{\c{e_1,s}}{n_1}\si \S{\c{e_2,s}}{n_2}}{o \mbox{ operație întreagă și $n = n_1 \mathrel{o} n_2$}}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Inducție deductivă}{Exemplu}
\begin{theorem}[Corespondență între semantica naturală și mașina SMC]
Dacă $\S{\c{e,s}}{n}$ atunci $\c{e\cdot c, r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$.
\end{theorem}
\begin{block}{Demonstrație (inducție deductivă asupra relației $\S{}{}$)}
  \begin{description} 
     \item[$\reg{\S{\c{n,s}}{n}}{}{n \mbox{ întreg}}$:] $\c{n \cdot c, r, s} \xrightarrow{\mbox{IntCt}} \c{c, n\cdot r, s}$ 
    \item[$\reg{\S{\c{{\mathrel{!} l},s}}{n}}{}{l \mbox{ locație, cu $l\in Dom(s)$ și $s(l)=n$}}$ :] 
$\c{{\mathrel{!} l} \cdot c, r, s} \xrightarrow{\mbox{Loc}} \c{c, n\cdot r, s}$ 
    \item[$\reg{\S{\c{e_1\mathrel{o} e_2,s}}{n}}{\S{\c{e_1,s}}{n_1}\si \S{\c{e_2,s}}{n_2}}{o \mbox{ operație întreagă și $n = n_1 \mathrel{o} n_2$}}$ :]

     \item[]\vspace{-1ex}$\begin{array}{l}
  \c{e_1\mathrel{o} e_2 \cdot c, r, s} \xrightarrow{\mbox{IntOpC}} \c{e_1 \cdot e_2 \cdot o \cdot c, r, s} \xrightarrow{\mbox{ip. ind}}
\\
  \c{e_2 \cdot o \cdot c, n_1 \cdot r, s}  \xrightarrow{\mbox{ip. ind}}   \c{o \cdot c, n_2 \cdot n_1 \cdot r, s}  \xrightarrow{\mbox{IntOp}}
\\
   \c{c, n \cdot r, s}
\end{array} $
  \end{description}
\end{block}
\end{frame}

\end{section}

\begin{section}{O semantica naturală pentru limbajului IMP}
\begin{frame}{Evaluarea fragmentelor de programe}
\begin{itemize}
\item Expresiile (aritmetice sau booleene) se evaluează la valori
\item Comenzile modifică starea
\vitem Considerăm „valoare“ a execuției unui (fragment de) program o pereche $\c{v,s}$, unde
\begin{itemize}
\item $s$ este starea obținută după execuție
\item $v$ este un întreg (pentru expresii aritmetice), o valoare booleană (pentru comparații) sau {\tt skip} (pentru comenzi)
\end{itemize}
\vitem Definim recursiv relația de evaluare $\S{\c{p,s}}{\c{v,s'}}$
\end{itemize}
\end{frame}

\begin{frame}{Evaluarea expresiilor}

\begin{itemize}
\item[] $\reg[ct]{\S{\c{v,s}}{\c{v,s}}}{}{v \mbox{ întreg sau boolean}}$

\vitem[]
$\reg[loc]{\S{\c{{\mathrel{!} l},s}}{\c{n,s}}}{}{l \mbox{ locație, cu $l\in Dom(s)$ și $s(l)=n$}}$

\vitem[]
$\reg[op]{\S{\c{e_1\mathrel{o} e_2,s}}{\c{v,s_2}}}{\S{\c{e_1,s}}{\c{n_1, s_1}}\si \S{\c{e_2,s_1}}{\c{n_2, s_2}}}{v = n_1 \mathrel{o} n_2}$

\end{itemize}

\end{frame}

\begin{frame}{Evaluarea comenzilor nerepetitive}

\begin{itemize}
\item[] $\reg[skip]{\S{\c{\Sskip,s}}{\c{\Sskip,s}}}{}{}$

\vitem[]
$\reg[asgn]{\S{\c{{l\mathrel{:=} e},s}}{\c{\Sskip,s''}}}{\S{\c{e,s}}{\c{n,s'}}}{s'' = s'[ l \mapsto n]}$

\vitem[]
$\reg[seq]{\S{\c{c_1\mathrel{;} c_2,s}}{\c{\Sskip,s_2}}}{\S{\c{c_1,s}}{\c{\Sskip, s_1}}\si \S{\c{c_2,s_1}}{\c{\Sskip, s_2}}}{}$

\vitem[]
$\reg[if-true]{\S{\c{\Sif b \Sthen c_1 \Selse c_2,s}}{\c{\Sskip,s_1}}}{\S{\c{b,s}}{\c{\Strue, s'}}\si \S{\c{c_1,s'}}{\c{\Sskip, s_1}}}{}$

\vitem[]
$\reg[if-false]{\S{\c{\Sif b \Sthen c_1 \Selse c_2,s}}{\c{\Sskip,s_2}}}{\S{\c{b,s}}{\c{\Sfalse, s'}}\si \S{\c{c_2,s'}}{\c{\Sskip, s_2}}}{}$


\end{itemize}
\end{frame}

\begin{frame}{Evaluarea lui $\Swhile$}
\ 

\medskip\vfill
$\reg{\S{\c{\Swhile b \Sdo c,s}}{\c{\Sskip,s'''}}}{\S{\c{b,s}}{\c{\Strue, s'}}\si \S{\c{c,s'}}{\c{\Sskip, s''}}\si \S{\c{\Swhile b \Sdo c,s''}}{\c{\Sskip,s'''}}}{}$

\hfill ({\sc while-true})

\vfill
$\reg[while-false]{\S{\c{\Swhile b \Sdo c,s}}{\c{\Sskip,s'}}}{\S{\c{b,s}}{\c{\Sfalse, s'}}}{}$

\vfill
\end{frame}

\begin{frame}{Ce putem/vrem să demonstrăm}
\begin{itemize}
\item Corespondența completă între semantica naturală și mașina SMC: dacă $\S{\c{St, s}}{\c{\Sskip, s'}}$ atunci \[\c{St\cdot c, r, s} \longrightarrow^\ast \c{c, r, s'}\]
\vitem Programul $c$ dat de $\Swhile {\Strue} \Sdo {\Sskip}$ nu poate fi evaluat.  Nu există stările $s, s'$ și valoarea $v$ astfel încât $\S{\c{c,s}}{\c{v,s'}}$. 
\end{itemize}
\end{frame}


\end{section}

\end{document}



