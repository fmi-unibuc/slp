\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}
\usepackage[all]{xy}

\title[SLP---IMP]{Semantică operațională}
\subtitle{Limbajul IMP—Implementare și decizii de proiectare} \begin{document}
\begin{frame}
  \titlepage
\end{frame}
\begin{section}{Implementare}
\begin{frame}{Implementare}{Mai multe opțiuni}
\begin{itemize}
\item Directă:  reprezentarea regulilor direct într-un limbaj cu suport pentru unificare/matching și căutare
\begin{itemize}
\item Maude / Prolog
\end{itemize}
\item Interpretor care definește funcții de evaluare într-un pas pornind de la structura programelor
\item Compilare bazată pe transformări de limbaj
\begin{itemize}
\item Mașină virtuală bazată pe stive (progam/valori)
\item Cod nativ
\item Vedeți proiectul CompCert \url{http://compcert.inria.fr/}: un compilator pentru C cu demonstratie de corectitudine.
\end{itemize} 
\end{itemize}

\vfill
\structure{Observație: }
Codarea regulilor de tranziție ca funcție e permisă de faptul că semantica IMP e puternic deterministă
\begin{itemize}
  \item Existența a cel mult un succesor pentru o configurație
  \item În caz contrar funcția de un pas ar trebui să calculeze o mulțime 
\end{itemize}
\end{frame}
\end{section}

\begin{section}{Proiectarea limbajului IMP}
\begin{frame}{Ordinea de evaluare a operanzilor}
\begin{itemize}
\item Ce ordine de evaluare specifică regulile din semantica limbajului IMP?
\begin{itemize}
\vitem[] $\reg[OpS]{\Ss{\c{e_1 \mathrel{op} e_2,\stare}}{\c{e_1' \mathrel{op} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$
\vitem[] $\reg[OpD]{\Ss{\c{n_1 \mathrel{op} e_2,\stare}}{\c{n_1 \mathrel{op} e_2',\stare'}}}{\Ss{\c{e_2,\stare}}{\c{e_2',\stare'}}}{}$
\end{itemize}
\item<2-> Cum specificăm o ordine de la dreapta la stânga?
\onslide<3->
\begin{itemize}
\vitem[] $\reg[OpD]{\Ss{\c{e_1 \mathrel{op} e_2,\stare}}{\c{e_1 \mathrel{op} e_2',\stare'}}}{\Ss{\c{e_2,\stare}}{\c{e_2',\stare'}}}{}$
\vitem[] $\reg[OpS]{\Ss{\c{e_1 \mathrel{op} n_2,\stare}}{\c{e_1' \mathrel{op} n_2',\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$
\end{itemize}
\item<3-> Cum specificăm că ordinea e complet arbitrară?
\end{itemize}
\end{frame}

\begin{frame}{Rezultatul atribuirii}
\begin{itemize}
\item Pentru limbajul IMP rezultatul atribuirii e $\Sskip$
\begin{itemize}
\item[] $\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$
\vitem[] $\reg[Secv]{\Ss{\c{\Sskip \terminal{;} e_2,\stare}}{\c{e_2,\stare}}}{}{}$
\end{itemize}
\vitem<2-> Dar dacă am vrea să fie ca în C (\texttt{l1 := l2 := 5})?
\onslide<3->
\begin{itemize}
\item[] $\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{n,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$
\vitem[] $\reg[Secv]{\Ss{\c{v \terminal{;} e_2,\stare}}{\c{e_2,\stare}}}{}{}$
\end{itemize}
\vitem<3> Dar dacă vrem să întoarcă vechea valoare 
\begin{itemize}
\item Care ar fi efectul excuției codului \texttt{l1 := l2 := !l1} ?
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{inițializarea locațiilor de memorie}
\begin{itemize}
\item Semantica IMP impune să fie inițializate în configurația inițială
\begin{itemize}
\item[] $\reg[Loc]{\Ss{\c{\terminal{!} l,\stare}}{\c{n, \stare}}}{}{l\in\Dom(\stare), n = \stare(l)}$
\vitem[] $\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$
\end{itemize}
\vitem<2-> Dacă am vrea ca toate locațiile să fie „inițializate“ cu 0?
\vitem<3> Dacă am vrea ca locațiile să fie inițializate la prima atribuire? 
\end{itemize}
\end{frame}

\begin{frame}{Ce conține memoria?}
\begin{itemize}
\item Chei: locații, valori: întregi
\begin{itemize}
\item[] $\reg[Loc]{\Ss{\c{\terminal{!} l,\stare}}{\c{n, \stare}}}{}{l\in\Dom(\stare), n = \stare(l)}$
\vitem[] $\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$
\vitem[] $\reg[AtribD]{\Ss{\c{l \terminal{:=} e ,\stare}}{\c{l \terminal{:=} e' ,\stare'}}}{\Ss{\c{e,\stare}}{\c{e',\stare'}}}{}$
\end{itemize}
\vitem<2-> Dar dacă am vrea să putem stoca orice fel de valoare?  (\texttt{l := true})
\vitem<3-> Ar putea locațiile să fie și ele valori?  (\texttt{l1 := l2})
\vitem<4-> Bucăți de cod (funcții/fragmente de program) ca valori?
\vitem<5-> Declarații locale și domenii de vizibilitate?
\end{itemize}
\end{frame}

\begin{frame}{Tipurile de date primitive}
\begin{itemize}
\item tipul de date boolean nu e identificat cu cel întreg. De ce? Se poate?
\item Semantica folosește întregi nemărginiți, implementarea întregi pe 31 de biți.
\begin{itemize}
\item Se poate remedia problema?  Cum?
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Expresivitate}
\begin{block}{Este IMP suficient de expresiv?}
\begin{itemize}
\item[DA] \only<2>{E Turing complet}

\item[NU] \only<2>{Nu are funcții, tipuri complexe, \ldots}
\end{itemize}
\end{block}
\onslide<2>
\begin{block}{Este IMP prea expresiv?}
 Adică, sunt programe care n-aș vrea să le pot scrie, dar le pot?
\begin{itemize}
\item Putem detecta programe greșite înainte de rulare? Cum?
\item Scop: evitarea blocării programului în timpul execuției
\item Soluție: Asocierea de tipuri și verificarea statică a lor
\end{itemize}
\end{block}
\end{frame}

\end{section}

\end{document}



