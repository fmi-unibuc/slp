\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}
\usepackage{adjustbox}

% \usepackage{tkz-graph}
\newcommand{\arboreT}[2]{\begin{minipage}{\widthof{#1}}#1\end{minipage}\begin{minipage}{2em}: #2\end{minipage}}

%\newlength{\deltay}
%\setlength{\deltay}{1em}
%\newlength{\deltax}
%\setlength{\deltax}{1em}

%
%\newcommand{\so}[4][]{\Vertex[position={below=\deltay of #2},L={#4},#1]{#3}}
%\newcommand{\no}[4][]{\Vertex[position={above=\deltay of #2},L={#4},#1]{#3}}
%\newcommand{\ea}[4][]{\Vertex[position={right=\deltay of #2},L={#4},#1]{#3}}
%\newcommand{\we}[4][]{\Vertex[position={left=\deltay of #2},L={#4},#1]{#3}}
%\newcommand{\soea}[4][]{\Vertex[position={below right=\deltay and \deltax of #2},L={#4},#1]{#3}}
%\newcommand{\sowe}[4][]{\Vertex[position={below left=\deltay and \deltax of #2},L={#4},#1]{#3}}
%\newcommand{\noea}[4][]{\Vertex[position={above right=\deltay and \deltax of=#2},L={#4},#1]{#3}}
%\newcommand{\nowe}[4][]{\Vertex[position={above left=\deltay and \deltax of=#2},L={#4},#1]{#3}}
%\newcommand{\edge}[4][]{\Edge[label={#4},#1](#2)(#3)}
%
%\newcommand{\suc}[6][]{
%\ifthenelse{\equal{#3/#6}{1/1}\or\equal{#3/#6}{2/3}}{%
%  \so[#1]{#2}{#2#30}{#5}%
%  \Edge[label={\scriptsize #3},labelstyle={above right=-1pt and 1pt,midway,inner sep=0pt,minimum size=.1pt},#1](#2)(#2#30)
%  }{\ifthenelse{\equal{#3/#6}{1/2}\or\equal{#3/#6}{1/3}}{%
%    \sowe[#1]{#2}{#2#30}{#5}%
%  \Edge[label={\scriptsize #3},#1](#2)(#2#30)
%  }{\ifthenelse{\equal{#3/#6}{2/2}\or\equal{#3/#6}{3/3}}{%
%  \soea[#1]{#2}{#2#30}{#5}%
%  \Edge[label={\scriptsize #3},#1](#2)(#2#30)
%  }{\so[#1]{#2}{#2#30}{update succ macro}
%}
%}
%}
%  \so[#1]{#2#30}{#2#3}{#4}
%  \Edge[#1](#2#30)(#2#3)
%}
%
%\renewcommand{\var}[6][]{
%\ifthenelse{\equal{#3/#6}{1/1}\or\equal{#3/#6}{2/3}}{%
%  \so[#1]{#2}{#4}{$#4$:#5}%
%  \Edge[label={\scriptsize #3},labelstyle={above right=-1pt and 1pt,midway,inner sep=0pt,minimum size=.1pt},#1](#2)(#4)
%  }{\ifthenelse{\equal{#3/#6}{1/2}\or\equal{#3/#6}{1/3}}{%
%    \sowe[#1]{#2}{#4}{$#4$:#5}%
%\Edge[label={\scriptsize #3},#1](#2)(#4)
%  }{\ifthenelse{\equal{#3/#6}{2/2}\or\equal{#3/#6}{3/3}}{%
%  \soea[#1]{#2}{#4}{$#4$:#5}%
%\Edge[label={\scriptsize #3},#1](#2)(#4)
%  }{\so[#1]{#2}{#4}{update var macro}
%}
%}
%}
%}
%
%\newcommand{\fir}[3][]{
%  \Vertex[L={#3},#1]{e0}
%  \so[#1]{e0}{e}{#2}
%  \Edge[#1](e0)(e)
%}
%
%\newcommand{\graph}[1]{
%
%\begin{tikzpicture}
%\pgfsetarrowsstart{latex} 
%  \GraphInit[vstyle=Normal]
% \SetUpEdge[lw         = .5pt,
%            style={-latex'},
%%            color      = orange,
%%            labelcolor = red!30,
%            labelstyle = {above=2pt,midway,inner sep=0pt,minimum size=.1pt}
%            ]
%  \tikzset{VertexStyle/.style={draw=none,inner sep=.5pt,minimum size=.1pt}}
%%  \tikzset{EdgeStyle/.style={-latex}}
%  #1
%\end{tikzpicture}
%}


\title[SLP---Demonstrații]{Demonstrații}
\subtitle{Metode de demonstrare în limbaje de programare}
\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{section}{Demonstrații}


\begin{frame}{Ce este o demonstrație?}
\begin{block}{O demonstrație formală}
\begin{itemize}
\item O derivare a concluziei din premize folosind \structure{logică formală}
\item Greu de scris de mână dar ușor de verificat automat
\item Exemplu: (în cursul acesta)
\end {itemize}
\end{block}
\begin{block}{O demonstrație informală, dar riguroasă}
\begin{itemize}
\item Noțiunea uzuală de demonstrație matematică
\item Un argument cu \structure{suficiente} detalii pentru a convinge că poate fi transformat într-o demonstrație formală
\end {itemize}
\end{block}
\begin{block}{Apă de ploaie}
Orice nu se încadrează în cele două cazuri de mai sus.
\url{http://jwilson.coe.uga.edu/EMT668/EMAT6680.F99/Challen/proof/proof.html}
\end {block}
\end{frame}

\begin{frame}{De ce demonstrăm lucruri „evidente“?}
\begin{itemize}
\item<1-> O demonstrație ne poate arăta \structure{de ce} e evidentă o afirmație
\vitem<2-> Uneori afirmațiile evidente se dovedesc a fi \alert{false}
\begin{itemize}
\item<3-> O demonstrație ne poate ajuta să descoperim ipoteze lipsă
\end{itemize}
\vitem<4-> Uneori afirmațiile evidente nu sunt deloc evidente
\begin{itemize}
\item<4-> E.g., Conjectura lui Kepler, teorema celor 4 culori
\end{itemize}
\vitem<5-> Demonstrațiile constructive pot conduce la metode algoritmice
\end{itemize}
\end{frame}


\begin{subsection}{Formalizare}
\begin{frame}{Cum demonstrăm formal o proprietate?}
\begin{block}{Evaluarea expresiilor aritmetice}
Orice expresie aritmetică în IMP se evaluează folosind mașina SMC la un rezultat întreg
\begin{itemize}
\item depinzând (doar) de starea memoriei
\item Într-un număr finit de pași
\item Fără a modifica restul configurației
\end{itemize}
\end{block}

\onslide<2>
\only<beamer|handout>{
\begin{theorem}
Pentru orice expresie aritmetică $E$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $E$, există un număr întreg $n$ astfel încât 
$$\c{E\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}}
\end{frame}

\begin{frame}{Inducție?}
\begin{theorem}
Pentru orice expresie aritmetică $E$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $E$, există un număr întreg $n$ astfel încât 
$$\c{E\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}

\begin{block}{Demonstrație (Ciornă)}
Inducție după "structura" lui $E$
\begin{itemize}
\item Ce înseamnă structura lui $E$?
\item Pot face inducție după ea?
\end{itemize}
\end{block}
\end{frame}

\end{subsection}
\end{section}


\begin{frame}{Ce este o expresie/program IMP?}
Am zis că mulțimea expresiilor IMP este definită de următoarea sintaxă:
\vspace{-5ex}\begin{syntaxBlock}{\AExp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid\terminal{!}\Id \Smid \AExp\iop \AExp}{}
\item[]\renewcommand{\defSort}{\BExp}
\syntax{\Bool \Smid \AExp\bop \AExp}{}
%\item[]\renewcommand{\defSort}{\Block}
%\syntax{\terminal{\{}\Stmt\terminal{\}} \Smid \terminal{\{}\terminal{\}}}{} 
\item[]\renewcommand{\defSort}{\Stmt}
\syntax{\Sskip \Smid \Id \terminal{:=} \AExp \Smid  \Stmt\terminal{;}\Stmt}{}
\syntaxCont{\Sif\BExp\Sthen \Block\Selse\Block \Smid \Swhile \BExp\Sdo \Block}{}
\item[]\renewcommand{\defSort}{\Pgm}
\syntax{\AExp \Smid \BExp \Smid \Stmt}{} 
\end{itemize}
}
\end{syntaxBlock}

Cum interpretăm/cum reprezentăm ca obiect matematic expresia:

\[\Sif 0 \leq {!l} \Sthen {\Sskip} \Selse ({\Sskip} \terminal{;} {l \terminal{:=} 0})\]  

\end{frame}

\begin{section}{Sintaxă abstractă}

\begin{frame}
{Cum reprezentăm ca obiect matematic programul}
{\[\Sif 0 \terminal{<=} {!l} \Sthen {\Sskip} \Selse ({\Sskip} \terminal{;} {l \terminal{:=} 0})\]} 

\onslide<2->
\begin{block}{Ca o listă de caractere}
['i', 'f', ' ', '0', '<', '=', '!', 'l', ' ', 't', 'h', 'e', 'n', ' ', '(', ')', ' ', 'e', 'l', 's', 'e', ' ', '(' \ldots]
\end{block}
\onslide<3->
\begin{block}{Ca o listă de simboluri (tokens)}
[IF, INT(0), LTE, DEREF, LOC("l"), THEN, SKIP, ELSE, LPAREN, \ldots]
\end{block} 
\onslide<4->
\begin{block}{Ca un arbore de sintaxă (abstract)}
\hfill
\begin{minipage}{.5\columnwidth}
\vspace{-3ex}\graph{
  \setlength{\deltay}{1ex}
  \Vertex[L={if\_then\_else\_},style={color=blue!75!black}]{If}
  \SOWE[L={\_<=\_},style={color=blue!75!black}](If){Leq} 
  \SOEA[L={\_;\_},style={color=blue!75!black}](If){Seq} 
  \SO[L={()}](If){Skip} 
  \SOWE[L={!l}](Leq){Deref} 
  \SO[L={0}](Leq){Zero}
  \SO[L={()}](Seq){Skip1} 
  \SOEA[L={l :=\_},style={color=blue!75!black}](Seq){Asgn} 
  \SO[L={0}](Asgn){Zero1}
  \Edge(If)(Leq)
  \Edge(Leq)(Deref)
  \Edge(Leq)(Zero)
  \Edge(If)(Skip)
  \Edge(If)(Seq)
  \Edge(Seq)(Skip1)
  \Edge(Seq)(Asgn)
  \Edge(Asgn)(Zero1)
}
\end{minipage}
\end{block}
\end{frame}





%\begin{section}{Formalizare}
%\begin{frame}{Cum demonstrăm formal o proprietate?}
%\begin{block}{Evaluarea expresiilor aritmetice}
%Orice expresie aritmetică în IMP se evaluează folosind mașina SMC la un rezultat întreg
%\begin{itemize}
%\item depinzând (doar) de starea memoriei
%\item Într-un număr finit de pași
%\item Fără a modifica restul configurației
%\end{itemize}
%\end{block}
%
%\onslide<2>
%\only<beamer|handout>{
%\begin{theorem}
%Pentru orice expresie aritmetică $E$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $E$, există un număr întreg $n$ astfel încât 
%$$\c{E\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}}
%\end{frame}
%
%\begin{frame}{Inducție?}
%\begin{theorem}
%Pentru orice expresie aritmetică $E$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $E$, există un număr întreg $n$ astfel încât 
%$$\c{E\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}
%
%\begin{block}{Demonstrație (Ciornă)}
%Inducție după "structura" lui $E$
%\begin{itemize}
%\item Ce înseamnă structura lui $E$?
%\item Pot face inducție după ea?
%\end{itemize}
%\end{block}
%\end{frame}
%
%\end{section}

\begin{frame}{Arbore abstract de sintaxă}

\hfill
\begin{minipage}{.5\columnwidth}
\graph{
  \Vertex[L={if\_then\_else\_},style={color=blue!75!black}]{If}
  \SOWE[L={\_<=\_},style={color=blue!75!black}](If){Leq} 
  \SOEA[L={\_;\_},style={color=blue!75!black}](If){Seq} 
  \SO[L={()}](If){Skip} 
  \SOWE[L={!l}](Leq){Deref} 
  \SO[L={0}](Leq){Zero}
  \SO[L={()}](Seq){Skip1} 
  \SOEA[L={l :=\_},style={color=blue!75!black}](Seq){Asgn} 
  \SO[L={0}](Asgn){Zero1}
  \Edge(If)(Leq)
  \Edge(Leq)(Deref)
  \Edge(Leq)(Zero)
  \Edge(If)(Skip)
  \Edge(If)(Seq)
  \Edge(Seq)(Skip1)
  \Edge(Seq)(Asgn)
  \Edge(Asgn)(Zero1)
}
\end{minipage} \hfill\;


\begin{itemize}
\item Pune în evidența structura: fiecare subarbore corespunde unei expresii
\item Ignoră detaliile „gramaticale“
\item Fiecare nod corespunde unei producții din gramatica dată
\end{itemize}
\end{frame}

\begin{frame}{Arbori abstracți de sintaxă}{Observații}
\begin{block}{$2 + 2 \neq 4$}
\hfill
\graph{
  \Vertex[L={\_+\_},style={color=blue!75!black}]{Plus}
  \SOWE[L={2}](Plus){Doi1} 
  \SOEA[L={2}](Plus){Doi2}
  \Edge(Plus)(Doi1)
  \Edge(Plus)(Doi2)
}\hfill{\Large $\neq$}\hfill
4\hfill\;
\end{block}

\begin{block}{$1 + 2 + 3$ e ambiguă și $1 + (2 + 3) \neq (1 + 2) + 3$}
\hfill\begin{minipage}{.3\columnwidth}
\graph{
  \Vertex[L={\_+\_},style={color=blue!75!black}]{Plus}
  \SOWE[L={\_+\_},style={color=blue!75!black}](Plus){Plus1} 
  \SOEA[L={3}](Plus){Trei}
  \SOWE[L={1}](Plus1){Unu}
  \SOEA[L={2}](Plus1){Doi}
  \Edge(Plus)(Plus1)
  \Edge(Plus)(Trei)
  \Edge(Plus1)(Unu)
  \Edge(Plus1)(Doi)
}
\end{minipage}
\hfill
\begin{minipage}{.3\columnwidth}
\graph{
  \Vertex[L={\_+\_},style={color=blue!75!black}]{Plus}
  \SOEA[L={\_+\_},style={color=blue!75!black}](Plus){Plus1} 
  \SOWE[L={1}](Plus){Unu}
  \SOWE[L={2}](Plus1){Doi}
  \SOEA[L={3}](Plus1){Trei}
  \Edge(Plus)(Plus1)
  \Edge(Plus)(Unu)
  \Edge(Plus1)(Trei)
  \Edge(Plus1)(Doi)
}
\end{minipage}
\hfill\;
\end{block}

\begin{block}{Parantezele nu fac parte din gramatică --- au doar rol de dezambiguizare}
\[1 + 2 = (1 + 2) = (1) + (2) = (((1) + ((((2))))))\]
\end{block}
\end{frame}

\begin{subsection}{Tip abstract de date}

\begin{frame}[fragile]{\only<beamer|handout>{Tip abstract de date}}{Reprezentăm programele ca termeni algebrici}
\begin{block}{Signatură algebrică (în Haskell)}
\begin{asciihs}
  data IExp = Int Int                  -- integer injection
            | Iop Iop IExp IExp        -- integer operation 
            | Loc Loc                  -- location !

  data BExp = Bool Bool                -- boolean injection
            | Bop Bop IExp IExp        -- integer comparison 

  data Cmd  = skip                     -- skip
            | Seq Cmd Cmd              -- seq composition ;
            | Asgn Loc IExp            -- assignment :=
            | If BExp Cmd Cmd          -- conditional
            | While BExp Cmd           -- while loop
\end{asciihs}
\end{block} 
\end{frame}

\begin{frame}[fragile]{\only<beamer|handout>{Tip abstract de date}}{Reprezentăm programele ca termeni algebrici}
\begin{block}{Signatură algebrică (în Maude)}
\begin{asciik}
  sorts IExp BExp Cmd . 
  op int : Int -> IExp .               --- integer injection
  op iop : Iop IExp IExp -> IExp .     --- integer operation 
  op loc : Loc -> IExp .               --- location !
  op bool : Bool -> BExp .             --- boolean injection
  op bop : Bop IExp IExp -> BExp .     --- integer comparison 
  op skip : -> Cmd .                   --- skip
  op seq : Cmd Cmd -> Cmd .            --- seq composition ;
  op asgn : Loc IExp -> Cmd .          --- assignment :=
  op if : BExp Cmd Cmd -> Cmd .        --- conditional
  op while : BExp Cmd -> Cmd .         --- while loop
\end{asciik}
\end{block}
\end{frame}

\begin{frame}[fragile]{Reprezentarea AST ca termen}
\begin{block}{Program\hspace{8em} Termen AST în Haskell}
\begin{minipage}{.3\columnwidth}
\begin{asciic}
 x := 10 ;
(sum := 0 ;
 while (0 <= !x)  do 
   (sum := !sum + !x ;
    x := !x - 1
   )
 )
\end{asciic}
\end{minipage}\hfill
\begin{minipage}{.7\columnwidth}
\footnotesize
\begin{verbatim}
 Seq (Asgn "x" (Int 10))
(Seq (Asgn "sum" (Int 0))
     (While (Bop "<=" (Int 0) (Loc "x""))
      (Seq (Asgn "sum" (Iop "+" (Loc "sum") (Loc "x")))
             (Asgn "x" (Iop "-" (Loc "x") (Int 1)))
       )))
\end{verbatim}
\end{minipage}
\end{block}
\begin{itemize}
\item Pentru a ușura notația lucrăm cu reprezentarea sintactică (stânga)
\item Folosim paranteze pentru dezambiguizare
\item Asociem (mental) fiecărei fraze program termenul AST corespunzător
\item Identificăm termenul AST cu arborele asociat
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Reprezentarea AST ca termen}
\begin{block}{Program\hspace{8em} Termen AST în Maude}
\begin{minipage}{.3\columnwidth}
\begin{asciic}
 x := 10 ;
(sum := 0 ;
 while (0 <= !x)  do 
   (sum := !sum + !x ;
    x := !x - 1
   )
 )
\end{asciic}
\end{minipage}\hfill
\begin{minipage}{.64\columnwidth}
\footnotesize
\begin{verbatim}
 seq(asgn(x,int(10)),
 seq(asgn(sum,int(0)),
     while(bop(<=, int(0), loc(x)),
       seq(asgn(sum, iop(+, loc(sum), loc(x))),
           asgn(x, iop(-, loc(x), int(1)))
       ))
 ))
\end{verbatim}
\end{minipage}
\end{block}
\end{frame}

\end{subsection}
\end{section}


%\begin{frame}[fragile]{Tip abstract de date pentru sintaxă}{Reprezentare în OCaml}
%\begin{asciiml}
%type l = string
%type op = Plus | Mic                  (* op ::= + | <=           *)
%type e =                              (* e ::=                   *)
%(***  frunze / noduri terminale  ***)
%  | Int of int                        (*     n                   *)
%  | Bool of bool                      (*   | b                   *)
%  | Skip                              (*   | skip                *)
%  | Loc of l                          (*   | ! l                 *)
%(***  Noduri unare ***)
%  | Atrib of l * e                    (*   | l := e              *)
%(***  Noduri binare ***)
%  | Op of e * op * e                  (*   | e op e              *)
%  | Secv of e * e                     (*   | e ; e               *)
%  | While of e * e                    (*   | while e do e        *)
%(*** Noduri ternare ***)
%  | If of e * e * e                   (*   | if e then e else e  *)
%\end{asciiml}
%\end{frame}
%
%\begin{frame}[fragile]{Reprezentarea AST ca termen}
%\begin{block}{Program\hspace{5em} Arbore de sintaxă (Reprezentare în OCaml)}
%\begin{minipage}{.25\columnwidth}
%\begin{asciic}
%( x := 10) ;
%((sum := 0) ;
% while (1 <= !x)  
% do 
%   (sum := (!sum + !x)) ;
%   (x := (!x + -1))
% done
% )
%\end{asciic}
%\end{minipage}\hfill
%\begin{minipage}{.7\columnwidth}
%\footnotesize
%\begin{asciiml}
% Seq(Atrib("x",Int(10)),
% Seq(Atrib("sum",Int(0)),
%     While(Op(Int(0), Mic, Loc("x")),
%       Seq(Atrib("sum", Op(Loc("sum"), Plus, Loc("x"))),
%           Atrib("x", Op(Loc(x), Plus, Int(-1)))
%       ))
% ))
%\end{asciiml}
%\end{minipage}
%\end{block}
%\begin{itemize}
%\item Pentru a ușura notația lucrăm cu reprezentarea sintactică (stânga)
%\item Folosim paranteze pentru dezambiguizare
%\item Asociem (mental) fiecărei fraze program termenul AST corespunzător
%\item Identificăm termenul AST cu arborele asociat
%\end{itemize}
%\end{frame}
%\end{subsection}
%\end{section}
%
%
%\begin{subsection}{Aplicații}
%\begin{frame}<handout:0|article:0>{Inducție structurală}{Exemplu}
%\begin{theorem}
%Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
%$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}
%\begin{block}{Reguli SMC pentru expresii aritmetice $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
%$\begin{array}{l@{\extracolsep{1em}}r@{{}\longrightarrow{}}l}
%\mbox{IntCt}&
%\c{n\cdot c,r,s} & \c{c, n \cdot r, s}
%\\[1ex]
%\mbox{Loc}&
%\c{\terminal{!} l\cdot c,r,s} & \c{c, n \cdot r, s}  \Sdaca s(l) = n
%\\[1ex]
%\mbox{IntOpC}&
%\c{(E_1 \iop E_2) \cdot c, r, s} & \c{E_1 \cdot E_2 \cdot \iop \cdot c, r, s}
%\\[1ex]
%\mbox{IntOp}&
%\c{\iop \cdot c, n_2\cdot n_1 \cdot r, s} & \c{c, n \cdot r, s} \Sdaca n_1 \iop n_2 = n
%\end{array}$
%\end{block}
%\end{frame}
%
%\begin{frame}{\only<beamer|handout>{Inducție structurală}}{Exemplu}
%  \setcounter{theorem}{0}
%\begin{theorem}
%Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
%$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}
%
%\begin{block}{Demonstrație (%
%Inducție structurală asupra  lui $e$)\hfill  $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
%\onslide<2>
%\begin{enumerate}
%\item \structure{$e = n$}, unde $n$ întreg, atunci aplicăm axioma (IntCt) și avem 
%$\c{n\cdot c,  r, s} \xrightarrow{IntCt} \c{c, n\cdot r, s}$
%\item \structure{$e = \mathop{!} l$}, unde $l$ locație, atunci aplicăm axioma (Loc) și avem 
%$\c{! l\cdot c,  r, s} \xrightarrow{Loc} \c{c, n\cdot r, s}$, unde $n=s(l)$ există  ($s$ definit pentru $l$)
%\end{enumerate}
%\end{block}
%\end{frame}
%
%\begin{frame}<handout:0|article:0>{Inducție structurală}{Exemplu}
%\begin{theorem}
%Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
%$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}
%\begin{block}{Reguli SMC pentru expresii  aritmetice $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
%$\begin{array}{l@{\extracolsep{1em}}r@{{}\longrightarrow{}}l}
%\mbox{IntCt}&
%\c{n\cdot c,r,s} & \c{c, n \cdot r, s}
%\\[1ex]
%\mbox{Loc}&
%\c{\terminal{!} l\cdot c,r,s} & \c{c, n \cdot r, s}  \Sdaca s(l) = n
%\\[1ex]
%\mbox{IntOpC}&
%\c{(E_1 \iop E_2) \cdot c, r, s} & \c{E_1 \cdot E_2 \cdot \iop \cdot c, r, s}
%\\[1ex]
%\mbox{IntOp}&
%\c{\iop \cdot c, n_2\cdot n_1 \cdot r, s} & \c{c, n \cdot r, s} \Sdaca n_1 \iop n_2 = n
%\end{array}$
%\end{block}
%\end{frame}
%
%
%
%\begin{frame}{\only<beamer|handout>{Inducție structurală}}{\only<beamer|handout>{Exemplu}}
%\only<beamer|handout>{
%\begin{theorem}
%Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
%$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
%\end{theorem}}
%
%\begin{block}{\only<beamer|handout>{Demonstrație (%
%Inducție structurală asupra  lui $e$)\hfill  $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}}
%\begin{enumerate}
%  \setcounter{enumi}{2}
%  \item 
%\structure{$e = e_1 \iop e_2$}, unde $e_1, e_2$ expresii
%\onslide<2>
%\begin{itemize}
%\item $\c{(e_1 \iop e_2) \cdot c, r, s}  \xrightarrow{IntOpC} \c{e_1 \cdot e_2 \cdot \iop \cdot c, r, s}$
%\item $\c{e_1 \cdot e_2 \cdot \iop \cdot c, r, s} \longrightarrow^\ast \c{e_2 \cdot \iop \cdot c, n_1 \cdot r, s}$ \hfill (ip. inducție)
%\item $\c{e_2 \cdot \iop \cdot c, n_1 \cdot r, s}  \longrightarrow^\ast \c{\iop \cdot c, n_2 \cdot n_1 \cdot r, s} $ \hfill (ip. inducție)
%\item $\c{\iop \cdot c, n_2 \cdot n_1 \cdot r, s}\xrightarrow{IntOp} \c{c, n \cdot r, s}$, unde $n_1 \iop n_2 = n$
%\end{itemize}
%\end{enumerate}
%\end{block}
%\end{frame}
%
%\begin{frame}{Ce putem/vrem să mai demonstrăm}
%\begin{block}{Evaluarea expresiilor booleene}
%Orice expresie booleană în IMP se evaluează folosind mașina SMC la un rezultat boolean
%\begin{itemize}
%\item depinzând (doar) de starea memoriei
%\item Într-un număr finit de pași
%\item Fără a modifica restul configurației
%\end{itemize}
%\end{block}
%\begin{block}{Evaluarea instrucțiunilor simple}
%Orice program IMP care nu conține while se termină
%\begin{itemize}
%\item Modificând doar conținutul memoriei
%\end{itemize}
%\end{block}
%
%\end{frame}
%
%\end{subsection}


\begin{section}{Definiții recursive}

\begin{frame}{\only<beamer>{Definiții recursive}}{Exemple}
  \begin{block}{Numerele naturale (Peano)}
      \begin{itemize}
      \item $0 \in \mathbb{N}$
       \item Dacă $n \in \mathbb{N}$ atunci și $s(n) \in \mathbb{N}$
      \end{itemize}
  \end{block}
  \begin{block}{Limbajul descris de o gramatică \hfill 
\begin{minipage}{.35\columnwidth} \renewcommand{\syntaxKeyword}{}\syntax[\AExp]{\Int\Smid\terminal{!}\Loc \Smid \AExp\iop \AExp}{}\end{minipage}}
     \begin{itemize}
	 \item Orice număr întreg $n$ este expresie
         \item Pentru orice locație $l$, $\mathrel{!} l$ este expresie
         \item Pentru orice simbol de operație întreagă $o$\\
              Dacă $e_1$ și $e_2$ sunt expresii, atunci și $e_1 \mathrel{o} e_2$ este expresie
      \end{itemize}
  \end{block}
  \begin{itemize} 
        \item Arbori de parsare/arbori AST
        \item Termeni AST descriși de un tip abstract de date
       \item Termeni descriși de o signatură algebrică
\end{itemize}
\end{frame}

\begin{frame}{Reguli de deducție}
   \begin{block}{Definiție}
        O \structure{regulă de deducție} $r$ peste o mulțime T este o pereche $(H,c)$ unde 
         \begin{itemize}
             \item $H = \{h_1,\ldots,h_n\}\subseteq T$ este mulțimea (finită) de \structure{ipoteze} ale regulii
             \item $c\in T$ este \structure{concluzia} regulii
            \item Prezentare arborescentă: $\reg{c}{h_1\si h_2 \si \cdots \si h_n}{}$
         \end{itemize}         
        Dacă mulțimea $H$ a ipotezelor e vidă, $r$ se numește \structure{axiomă}.
   \end{block}

  \begin{block}{Exemplu ( Mulțimea numerelor Peano)}
\begin{itemize}
\item Fie $T = \{0,s,(,)\}^\star$ limbajul tuturor cuvintelor peste alfabetul $\{0, s,(,)\}$
\item Definim recursiv o submulțime a lui $T$ prin regulile de deducție $\cal R$:
\[\R = \{(\emptyset,0)\} \cup \{(\{t\},s(t)) \mid t\in T\} \]
\end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Scheme de reguli de deducție}
\structure{Scop:} Prezentarea compactă a unui sistem de reguli de deducție

\structure{Definiție:}
O schemă de reguli de deducție este de forma:
\[\displaystyle\reg[etichetă]{c}{h_1 \cdots h_n}{\mbox{\bf condiții}}\]
unde:
\begin{itemize}
\item $c$, $h_1$, $h_2$, \ldots, $h_n$ sunt termeni cu (meta)variabile
\item {\bf condiții} sunt constrângeri asupra variabilelor 
\end{itemize}

Regulile de deducție asociate schemei sunt  instanțe ale acesteia
\begin{itemize}
\item Obținute prin substituirea metavariabilelor cu valori concrete
\item Astfel încât constrângerile sunt satisfăcute
\end{itemize}

   \begin{block}{Exemplu (expresii aritmetice în IMP):} 
\begin{itemize}
\item[]
              \structure{Axiome:} \hfill $\displaystyle\reg[int]{n}{}{n \mbox{ intreg}}$  \hfill $\displaystyle\reg[loc]{\terminal{!}l}{}{l\mbox{ locație}}$\hfill\ 
  

\item[]              \structure{Regulă:} \hfill $\displaystyle\reg[op]{e_1 \mathrel{o} e_2}{e_1\si  e_2}{o \in \{+,\leq\}}$\hfill\;
\end{itemize}
       \end{block}
\end{frame}

\begin{frame}{Demonstrații deductive}{Prezentare ca arbori}
   \begin{block}{Definiție}
       Un \structure{arbore de demonstrație} folosind regullile $\cal R$ peste mulțimea $T$ satisface:
     \begin{itemize} 
         \item Orice nod este etichetat cu un element din $T$
        \item Daca multimea etichetelor copiilor unui nod este $H$ și eticheta nodului este $c$, atunci $(H,c) \in \cal R$
         \item Înălțimea arborelui este finită
      \end{itemize}
    Un arbore de demonstrație e o demonstrație pentru eticheta rădăcinii lui.
    \end{block}

 \begin{block}{Exemplu (expresii aritmetice)}
     \[\reg[op]{(3 + ! l) \leq 5 }{
            {\displaystyle\reg[op]{3 + ! l}{\displaystyle\reg[int]{3}{\done}{}\si \reg[loc]{ ! l}{\done}{}}{}\si \reg[int]{5}{\done}{}}{}}{}\]
  \end{block}
\end{frame}

\begin{frame}{Demonstrații deductive}{Prezentare liniară}
   \begin{block}{Definiție}
       O \structure{demonstrație} a lui $c$ folosind mulțimea de reguli $\cal R$  este o secvență
de reguli $(H_1, c_1), \ldots (H_n, c_n)$ satisfacând următoarele    
     \begin{itemize}
          \item $(H_i, c_i) \in \cal R$ pentru orice $1\leq i \leq n$
          \item $c_n = c$
          \item Orice ipoteză $h \in H_i$ a fost deja demonstrată, i.e., există $c_j = h$ cu $j<i$ 
     \end{itemize}
    \end{block}

  \begin{block}{Exemplu}
      $(\emptyset, 3)$,
      $(\emptyset, 5)$,
      $(\emptyset, ! l)$,
      $(\{3, !l \}, 3 + ! l)$,
     $(\{3 + ! l, 5\}, (3 + ! l) \leq 5)$.
  \end{block}
\end{frame}

\begin{frame}{Definiții recursive}{Definiție formală}
  \begin{block}{Definiție}
     Mulțimea \structure{definită recursiv} de regulile $\R$ este submulțimea elementelor $c$ ale lui $T$ demonstrabile folosind $\R$.

 Denumire alternativă: $\Th{\R}$ --- mulțimea \structure{teoremelor} lui $\R$

  \end{block}

\begin{theorem}
Mulțimea teoremelor lui $\cal R$ este cea mai mică mulțime A „închisă“ la regulile din $\cal R$, i.e.,  satisfăcând proprietatea următoare:
      
\hfill pentru orice regulă $(H,c) \in \R$, dacă $H\subseteq A$ atunci $c\in A$.\hfill\;
\end{theorem}
\end{frame}

\begin{frame}{Mulțimea teoremelor}{Demonstrație}
\begin{theorem}
Mulțimea teoremelor lui $\cal R$ este cea mai mică mulțime A „închisă“ la regulile din $\cal R$, i.e.,  satisfăcând proprietatea următoare:
      
\hfill pentru orice regulă $(H,c) \in \R$, dacă $H\subseteq A$ atunci $c\in A$.\hfill\;
\end{theorem}
\begin{proof}[Schiță de demonstrație --- prezentarea liniară]
\begin{itemize}
\item $\Th{\R}$ închisă la $\R$
\begin{itemize}
\item<2-> Fie $(H,c) \in \R$ astfel încât $H = \{h_1, h_2, \ldots, h_n\} \subseteq  \Th{\R}$
\item<2-> Pentru fiecare $h_i\in H$, fie $D(h_i)$ o demonstrație pentru $h_i$
\item<2-> Atunci $D(h_1), D(h_2),\ldots,D(h_n), (H,c)$ e o demonstrație pentru $c$
\end{itemize}
\item $\Th\R$ cea mai mică mulțime închisă la $\R$
\begin{itemize}
\item<3> Fie $A$ închisă la $\R$. Arătăm că $c\in \Th{\R} \implies c\in A$
\item <3>Inducție (totală) după lungimea demonstrației lui $c$
\end{itemize}
\end{itemize}
\end{proof}
\end{frame}


\begin{frame}{Cele două definiții ale demonstrabilității sunt echivalente}
\begin{theorem}
$c$ e demonstrabilă folosind arbori de demonstrație dacă și numai dacă $c$ e demonstrabilă folosind demonstrații liniare. 
\end{theorem}
\begin{proof}[Idee de demonstrație (Temă)]
Demonstrăm teorema precedentă folosind prezentarea arborescentă.
\end{proof}
\end{frame}

\end{section}


\begin{section}{Inducție}
\begin{frame}{Inducție deductivă}

\begin{block}{Formulare matematică}
Dacă $\cal R$ sistem de reguli de deducție peste $T$ și $P$ proprietate peste $T$,
\[(\forall (H,c)\in \R.((\forall h\in H.P(h))\implies P(c)))\implies \forall t\in{\sf Th}(\R).P(t)\]
\end{block}


\begin{block}{Adică}
  Dacă mulțimea elementelor care satisfac proprietatea $P$ este închisă la ${\cal R}$, atunci ea conține teoremele lui ${\cal R}$. 
\end{block}
\end{frame}

\begin{frame}{Inducție deductivă pentru mulțimi definite recursiv}

\begin{block}{Principiul inducției deductive}
Pentru a demonstra că $P$ este adevărată pentru orice element al unei mulțimi $A$ definită recursiv de regulile din $\cal R$:
\begin{itemize}
  \item Considerăm mulțimea elementelor din $A$ pentru care $P$ e adevărată
  \item Arătăm că este închisă la regulile din $\cal R$
\end{itemize}
(instanțierea rezultatului precedent pentru $P'(c) = c \in A  \wedge P(c)$)
\end{block}

\begin{block}{Concret}
Pentru fiecare regulă $(H,c)$, cu \structure{$H\subseteq A$}
\begin{description} 
\item[Ipoteza de inducție] Presupunem că $P(h)$ e adevărată pentru orice $h\in H$,
\item[Concluzie] Demonstrăm că $P(c)$ e adevărată.
\end{description}	
\end{block}
\end{frame}


%\begin{frame}{Inducție slabă/incompletă}
%
%\begin{block}{Formulare matematică}
%Pentru orice proprietate $P$,
%\[\left(P(0) \wedge (\forall n\in\Nat. P(n) \implies P(n+1))\right)\implies \forall n\in\Nat. P(n)\]
%\end{block}
%
%\onslide<2>
%\begin{block}{Așadar...}
%\begin{description}
%\item[Caz de bază] Demonstrăm că $P(0)$ e adevărată
%\item[Pas de inducție] 
%Fie $n$ un număr natural arbitrar, fixat 
%\begin{itemize} 
%\item Presupunem că $P(n)$ e adevărată
%\item Demonstrăm că $P(n+1)$ este adevărată 
%\end{itemize}
%\item[Concluzie] $P(n)$ este adevărată pentru orice număr natural $n$.
%
%\end{description}
%\end{block}
%\end{frame}

\begin{frame}{Exemplu}{Inducție pe numere naturale}

\begin{itemize}
\item Fie $\Nat$ mulțimea definită de regulile:

\hfill $0$\hfill $\displaystyle\reg{s(n)}{n}{}$\hfill\;

\vitem Instanțiem principiul inducției deductive pentru acest sistem
$(((\forall h\in\emptyset.P(h)) \implies P(0))\wedge\forall n\in\Nat.((\forall h\in\{n\}.P(h)) \implies P(s(n))))$

\hfill $\implies \forall n\in\Nat.P(n)$

\vitem Prin simplificare se obține principiul inducției matematice
\[\left(P(0) \wedge (\forall n\in\Nat. P(n) \implies P(s(n)))\right)\implies \forall n\in\Nat. P(n)\]
\end{itemize}
\end{frame}

\begin{subsection}{Inducție structurală în IMP}

\begin{frame}{Arbori de sintaxă}
\begin{block}{Sintaxă}
\vspace{-5ex}\begin{syntaxBlock}{\AExp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid\terminal{!}\Id \Smid \AExp\iop \AExp}{}
\item[]\renewcommand{\defSort}{\BExp}
\vspace{-3ex}\syntax{\Bool \Smid \AExp\bop \AExp}{}
%\item[]\renewcommand{\defSort}{\Block}
%\syntax{\terminal{\{}\Stmt\terminal{\}} \Smid \terminal{\{}\terminal{\}}}{} 
\item[]\renewcommand{\defSort}{\Stmt}
\vspace{-3ex}\syntax{\Sskip \Smid \Id \terminal{:=} \AExp \Smid  \Stmt\terminal{;}\Stmt}{}
\syntaxCont{\Sif\BExp\Sthen \Block\Selse\Block \Smid \Swhile \BExp\Sdo \Block}{}
\item[]\renewcommand{\defSort}{\Pgm}
\vspace{-3ex}\syntax{\AExp \Smid \BExp \Smid \Stmt}{} 
\end{itemize}
}
\end{syntaxBlock}
\vspace{-2ex}
\end{block}

\begin{block}{Univers}
Fie $\mathbb{A}$ totalitatea arborilor cu etichete din mulțimea:
\vspace{-2ex}
\[\begin{array}{r@{\;}l}\mathbb{E} = & \{n\mid n\in\mathbb{Z}\} \cup \{\Strue, \Sfalse\}\cup \{\_+\_, \_\leq\_\} \cup \{\Sif\_\Sthen\_\Selse\_\}
\\ 
\cup &
\{! l \mid l\in  \mathbb{L}\}\cup \{l :=\_\mid l\in \mathbb{L}\}
\cup
\{\Sskip, \_;\_, \Swhile\_\Sdo\_\}
\end{array}\]

Definim universul $\mathbb{U} = \mathbb{A} \times \{E, B, C, P\}$ și notăm $a : t$ pentru $(a, t) \in \mathbb{U}$.
\end{block} 

\begin{block}{Arbori abstracți de sintaxă (și tipul lor)}
Definiți recursiv ca submulțime universului definit mai sus
\end{block}
\end{frame}

\begin{frame}
{Reguli de formare a arborilor abstracți de sintaxă}

$\reg[sN]{\displaystyle n : E}{}{n\in \mathbb{Z}}$
\hfill $\reg[sB]{\displaystyle b : B}{}{b\in \{\Strue, \Sfalse\}}$

\vfill$\reg[s+]{\arboreT{\arbore{$\_+\_$}{$e_1$}{}{$e_2$}}{E}}{\displaystyle a_1 : E \si a_2 : E}{}$
\hfill$\reg[s<=]{\arboreT{\arbore{$\_\mathrel{<=}\_$}{$e_1$}{}{$e_2$}}{E}}{\displaystyle a_1 : E \si a_2 : E}{}$

\vfill $\reg[sAtrib]{\arboreT{\arbore{l := \_}{}{a}{}}{C}}{\displaystyle a : E}{l\in \mathbb{L}}$
\hfill$\reg[sLoc]{\displaystyle !l : E}{}{l\in \mathbb{L}}$

\vfill$\reg[sSecv]{\arboreT{\arbore{\_;\_}{$e_1$}{}{$e_2$}}{C}}{\displaystyle e_1 : C \si e_2 : C}{}$
\hfill$\reg[sSkip]{\displaystyle \Sskip : C}{}{}$

 \vfill $\reg[sIf]{\arboreT{\arbore{$\Sif\_\Sthen\_\Selse\_$}{$a_1$}{$a_2$}{$a_3$}}{C}}{\displaystyle a_1 : B \si a_2 : C\si a_3 : C}{}$
\hfill $\reg[sWhile]{\arboreT{\arbore{$\Swhile\_\Sdo\_\Sdone$}{$a_1$}{}{$a_2$}}{C}}{\displaystyle a_1 : B \si a_2 : C}{}$

\end{frame}


\begin{frame}{Principiul inducției structurale}{Inducție pe termeni definiți recursiv}
\begin{block}{Scop:} 
Demonstrăm că $P$ este adevărată pentru orice termen (AST) definit (recursiv) de o gramatică independentă de context. 
\end{block}

\begin{block}{Metoda:} 
Instanțiem principiul inducției deductive pentru sistemul de reguli indus de producțiile gramaticii.
\end{block}

\begin{block}{Concret} 
Pentru fiecare regulă de formare a expresiilor indusă de gramatică, 
\begin{description} 
\item[Ipoteza de inducție]  Presupunem că $P$ ține pentru subexpresiile componente
\item[Concluzie] Demonstrăm că $P$ ține și pentru expresia definită de regulă.
\end{description}	
\end{block}

\end{frame}

\begin{frame}{Cazuri de inducție structurală pentru IMP}
\begin{itemize}
\item[]\structure{Cazuri de bază.}  
Demonstrăm
\begin{itemize}
\item $P(n)$ pentru orice $n \in \mathbb{Z}$,
\item $P(\Strue)$ și $P(\Sfalse)$
\item $P(\Sskip)$
\item$P(\terminal{!} l)$ pentru orice $l\in \mathbb{L}$
\end{itemize}

\item[] \structure{Recursie simplă.}  
Demonstrăm că dacă $P(e)$ atunci și
\begin{itemize}
\item $P(l \terminal{:=} e)$ pentru orice $l \in \mathbb{L}$
\end{itemize}
\item[] \structure{Recursie dublă.}
Demonstrăm că dacă $P(e_1)$ și $P(e_2)$, atunci și
\begin{itemize}
\item $P(e_1 \terminal{o} e_2)$ pentru orice $o \in \{\leq, +\}$
\item $P(e_1 \terminal{;} e_2)$
\item $P(\Swhile e_1 \Sdo e_2 \Sdone)$ 
\end{itemize}
\item[]\structure{Recursie triplă.}
Demonstrăm că dacă $P(e_1)$, $P(e_2)$ și $P(e_3)$, atunci și 
\begin{itemize}
\item $P(\Sif e_1 \Sthen e_2 \Selse e_3)$ 
\end{itemize}
\end{itemize}
\end{frame}

\end{subsection}
%\begin{frame}{Inducție deductivă}{Exemplu}
%\begin{theorem}[Corespondență între semantica naturală și mașina SMC]
%Dacă $\S{\c{e,s}}{n}$ atunci $\c{e\cdot c, r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$.
%\end{theorem}
%\begin{block}{Demonstrație (inducție deductivă asupra relației $\S{}{}$)}
%  \begin{description} 
%     \item[$\reg{\S{\c{n,s}}{n}}{}{n \mbox{ întreg}}$:] $\c{n \cdot c, r, s} \xrightarrow{\mbox{IntCt}} \c{c, n\cdot r, s}$ 
%    \item[$\reg{\S{\c{{\mathrel{!} l},s}}{n}}{}{l \mbox{ locație, cu $l\in Dom(s)$ și $s(l)=n$}}$ :] 
%$\c{{\mathrel{!} l} \cdot c, r, s} \xrightarrow{\mbox{Loc}} \c{c, n\cdot r, s}$ 
%    \item[$\reg{\S{\c{e_1\mathrel{o} e_2,s}}{n}}{\S{\c{e_1,s}}{n_1}\si \S{\c{e_2,s}}{n_2}}{o \mbox{ operație întreagă și $n = n_1 \mathrel{o} n_2$}}$ :]
%
%     \item[]\vspace{-1ex}$\begin{array}{l}
%  \c{e_1\mathrel{o} e_2 \cdot c, r, s} \xrightarrow{\mbox{IntOpC}} \c{e_1 \cdot e_2 \cdot o \cdot c, r, s} \xrightarrow{\mbox{ip. ind}}
%\\
%  \c{e_2 \cdot o \cdot c, n_1 \cdot r, s}  \xrightarrow{\mbox{ip. ind}}   \c{o \cdot c, n_2 \cdot n_1 \cdot r, s}  \xrightarrow{\mbox{IntOp}}
%\\
%   \c{c, n \cdot r, s}
%\end{array} $
%  \end{description}
%\end{block}
%\end{frame}

\begin{subsection}{Aplicații}
\begin{frame}<handout:0|article:0>{Inducție structurală}{Exemplu}
\begin{theorem}
Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}
\begin{block}{Reguli SMC pentru expresii aritmetice $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
$\begin{array}{l@{\extracolsep{1em}}r@{{}\longrightarrow{}}l}
\mbox{IntCt}&
\c{n\cdot c,r,s} & \c{c, n \cdot r, s}
\\[1ex]
\mbox{Loc}&
\c{\terminal{!} l\cdot c,r,s} & \c{c, n \cdot r, s}  \Sdaca s(l) = n
\\[1ex]
\mbox{IntOpC}&
\c{(E_1 \iop E_2) \cdot c, r, s} & \c{E_1 \cdot E_2 \cdot \iop \cdot c, r, s}
\\[1ex]
\mbox{IntOp}&
\c{\iop \cdot c, n_2\cdot n_1 \cdot r, s} & \c{c, n \cdot r, s} \Sdaca n_1 \iop n_2 = n
\end{array}$
\end{block}
\end{frame}

\begin{frame}{\only<beamer|handout>{Inducție structurală}}{Exemplu}
  \setcounter{theorem}{0}
\begin{theorem}
Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}

\begin{block}{Demonstrație (%
Inducție structurală asupra  lui $e$)\hfill  $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
\onslide<2>
\begin{enumerate}
\item \structure{$e = n$}, unde $n$ întreg, atunci aplicăm axioma (IntCt) și avem 
$\c{n\cdot c,  r, s} \xrightarrow{IntCt} \c{c, n\cdot r, s}$
\item \structure{$e = \mathop{!} l$}, unde $l$ locație, atunci aplicăm axioma (Loc) și avem 
$\c{! l\cdot c,  r, s} \xrightarrow{Loc} \c{c, n\cdot r, s}$, unde $n=s(l)$ există  ($s$ definit pentru $l$)
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}<handout:0|article:0>{Inducție structurală}{Exemplu}
\begin{theorem}
Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}
\begin{block}{Reguli SMC pentru expresii  aritmetice $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}
$\begin{array}{l@{\extracolsep{1em}}r@{{}\longrightarrow{}}l}
\mbox{IntCt}&
\c{n\cdot c,r,s} & \c{c, n \cdot r, s}
\\[1ex]
\mbox{Loc}&
\c{\terminal{!} l\cdot c,r,s} & \c{c, n \cdot r, s}  \Sdaca s(l) = n
\\[1ex]
\mbox{IntOpC}&
\c{(E_1 \iop E_2) \cdot c, r, s} & \c{E_1 \cdot E_2 \cdot \iop \cdot c, r, s}
\\[1ex]
\mbox{IntOp}&
\c{\iop \cdot c, n_2\cdot n_1 \cdot r, s} & \c{c, n \cdot r, s} \Sdaca n_1 \iop n_2 = n
\end{array}$
\end{block}
\end{frame}



\begin{frame}{\only<beamer|handout>{Inducție structurală}}{\only<beamer|handout>{Exemplu}}
\only<beamer|handout>{
\begin{theorem}
Pentru orice expresie aritmetică $e$ în IMP și pentru  orice configurație $\c{c,r,s}$ a mașinii SMC în care $s$ e definită pentru toate locațiile lui $e$, există un număr întreg $n$ astfel încât 
$$\c{e\cdot c,  r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$$
\end{theorem}}

\begin{block}{\only<beamer|handout>{Demonstrație (%
Inducție structurală asupra  lui $e$)\hfill  $E$ ::= $n \Smid {\mathrel{"!"} l} \Smid E \mathrel{iop} E$}}
\begin{enumerate}
  \setcounter{enumi}{2}
  \item 
\structure{$e = e_1 \iop e_2$}, unde $e_1, e_2$ expresii
\onslide<2>
\begin{itemize}
\item $\c{(e_1 \iop e_2) \cdot c, r, s}  \xrightarrow{IntOpC} \c{e_1 \cdot e_2 \cdot \iop \cdot c, r, s}$
\item $\c{e_1 \cdot e_2 \cdot \iop \cdot c, r, s} \longrightarrow^\ast \c{e_2 \cdot \iop \cdot c, n_1 \cdot r, s}$ \hfill (ip. inducție)
\item $\c{e_2 \cdot \iop \cdot c, n_1 \cdot r, s}  \longrightarrow^\ast \c{\iop \cdot c, n_2 \cdot n_1 \cdot r, s} $ \hfill (ip. inducție)
\item $\c{\iop \cdot c, n_2 \cdot n_1 \cdot r, s}\xrightarrow{IntOp} \c{c, n \cdot r, s}$, unde $n_1 \iop n_2 = n$
\end{itemize}
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}{Ce putem/vrem să mai demonstrăm}
\begin{block}{Evaluarea expresiilor booleene}
Orice expresie booleană în IMP se evaluează folosind mașina SMC la un rezultat boolean
\begin{itemize}
\item depinzând (doar) de starea memoriei
\item Într-un număr finit de pași
\item Fără a modifica restul configurației
\end{itemize}
\end{block}
\begin{block}{Evaluarea instrucțiunilor simple}
Orice program IMP care nu conține while se termină
\begin{itemize}
\item Modificând doar conținutul memoriei
\end{itemize}
\end{block}

\end{frame}

\end{subsection}
\end{section}

\end{document}


\begin{subsection}{Inducție structurală pe tipul expresiilor}

\begin{frame}{Determinism puternic}
\begin{theorem}[Limbajul IMP este puternic determinist]
Dacă $\Ss{\c{e,\stare}}{\c{e_1,\stare_1}}$ și $\Ss{\c{e,\stare}}{\c{e_2,\stare_2}}$, atunci $e_1 = e_2$ și $\stare_1 = \stare_2$.
\end{theorem}
\begin{proof}[Idee de demonstrație]
 Fie $P$ proprietatea definită de 

\(P(e) \stackrel{def}{=} \forall s,e_1,s_1,e_2,s_2.\)
\[ \Ss{\c{e,s}}{\c{e_1,s_1}} \wedge \Ss{\c{e,s}}{\c{e_2,s_2}} \implies \c{e_1,s_1} = \c{e_2, s_2}\]

Demonstrăm că $P$ e adevărată pentru toate expresiile IMP prind inducție asupra structurii lui $e$.
\end{proof}
\end{frame}

\begin{frame}{Determinism puternic}
\only<beamer>{
\begin{theorem}[Limbajul IMP este puternic determinist]
Dacă $\Ss{\c{e,\stare}}{\c{e_1,\stare_1}}$ și $\Ss{\c{e,\stare}}{\c{e_2,\stare_2}}$, atunci $e_1 = e_2$ și $\stare_1 = \stare_2$.
\end{theorem}
}

\begin{block}{Definiție (Valoare)}
Spunem că $v$ e valoare, notat $\mathop{valoare}(v)$, dacă $v$ e întreg, boolean, sau $\Sskip$.
Fie $\mathbb{V}$ mulțimea valorilor, adică
\[\mathbb{V} = \mathbb{Z} \cup \{\Strue, \Sfalse\} \cup \{\Sskip\}\]
\end{block}

\begin{block}{Lemă (Valorile nu mai pot fi reduse)}
Dacă $v$ este valoare, atunci pentru orice stare a memoriei $s$, 
\[\c{v,s} \not\rightarrow\]
\end{block}
\end{frame}

\begin{frame}<handout:0>{Definiția sistemului de tranziție pentru limbajul IMP}
$\reg[+]{\Ss{\c{n_1 + n_2,\stare}}{\c{n,\stare}}}{}{n = n_1 + n_2}$
$\reg[$\leq$]{\Ss{\c{n_1 \terminal{<=} n_2,\stare}}{\c{b,\stare}}}{}{b = (n_1 \leq n_2)}$

\vfill { $\reg[OpS]{\Ss{\c{e_1 \mathrel{o} e_2,\stare}}{\c{e_1' \mathrel{o} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$\hfill
$\reg[OpD]{\Ss{\c{n_1 \mathrel{o} e_2,\stare}}{\c{n_1 \mathrel{o} e_2',\stare'}}}{\Ss{\c{e_2,\stare}}{\c{e_2',\stare'}}}{}$}

\vfill $\reg[Loc]{\Ss{\c{\terminal{!} l,\stare}}{\c{n, \stare}}}{}{l\in\Dom(\stare), n = \stare(l)}$
$\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$

\vfill$\reg[AtribD]{\Ss{\c{l \terminal{:=} e ,\stare}}{\c{l \terminal{:=} e' ,\stare'}}}{\Ss{\c{e,\stare}}{\c{e',\stare'}}}{}$

$\reg[Secv]{\Ss{\c{\Sskip \terminal{;} e_2,\stare}}{\c{e_2,\stare}}}{}{}$
$\reg[SecvS]{\Ss{\c{e_1 \terminal{;} e_2},\stare}{\c{e_1' \terminal{;} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$


\vfill $\reg[IfTrue]{\Ss{\c{\Sif  {\terminal{true}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_1,\stare}}}{}{}$ 
$\reg[IfFalse]{\Ss{\c{\Sif {\terminal{false}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_2,\stare}}}{}{}$ 
$\reg[IfS]{
 \Ss{\c{\Sif {e} \Sthen e_1 \Selse e_2,\stare}}{\c{\Sif  {e'} \Sthen e_1 \Selse e_2,\stare'}}
}{
  \Ss{\c{e,\stare}}{\c{e',\stare'}}
}
{}$

\vfill $\reg[While]{\Ss{\c{\Swhile {e_1} \Sdo e_2 \Sdone{},\stare}}{}}{}
{}$

\hfill $\c{\Sif {e_1} \Sthen (e_2\terminal{;} {\Swhile {e_1} \Sdo e_2 \Sdone}) \Selse  {\Sskip},\stare}$

\end{frame}


\begin{frame}{Cazuri de inducție structurală pentru IMP}{}
\begin{itemize}
\item[]\structure{Cazuri de bază.}  
Demonstrăm
\begin{itemize}
\item $P(n)$ pentru orice $n \in \mathbb{Z}$,
\item $P(\Strue)$ și $P(\Sfalse)$
\item $P(\Sskip)$
\item$P(\terminal{!} l)$ pentru orice $l\in \mathbb{L}$
\end{itemize}

\item[] \structure{Recursie simplă.}  
Demonstrăm că dacă $P(e)$ atunci și
\begin{itemize}
\item $P(l \terminal{:=} e)$ pentru orice $l \in \mathbb{L}$
\end{itemize}
\item[] \structure{Recursie dublă.}
Demonstrăm că dacă $P(e_1)$ și $P(e_2)$, atunci și
\begin{itemize}
\item $P(e_1 \terminal{o} e_2)$ pentru orice $o \in \{\leq, +\}$
\item $P(e_1 \terminal{;} e_2)$
\item $P(\Swhile e_1 \Sdo e_2 \Sdone)$ 
\end{itemize}
\item[]\structure{Recursie triplă.}
Demonstrăm că dacă $P(e_1)$, $P(e_2)$ și $P(e_3)$, atunci și 
\begin{itemize}
\item $P(\Sif e_1 \Sthen e_2 \Selse e_3)$ 
\end{itemize}
\end{itemize}
\end{frame}
\end{subsection}


\begin{subsection}{Inducție deductivă pe definiția relației de tip}

\begin{frame}{Proprietatea de a progresa a sistemului de tipuri}
\begin{theorem} Dacă $\tjud{e}{T}$ și $\Dom(\Gamma) \subseteq \Dom(s)$ atunci $e$ este valoare sau există $e'$, $s'$ astfel încât $\Ss{\c{e,s}}{\c{e',s'}}$.
\end{theorem}
\begin{proof}[Idee de demonstrație]
 Fie $P$ proprietatea definită de 

\(P(\tjud{e}{t}) \stackrel{def}{=} \mathop{value}(e) \vee (\forall s.\)
\[ \Dom(\Gamma) \subseteq \Dom(s) \implies \exists e',s'. \Ss{\c{e,s}}{\c{e',s'}}\]

Demonstrăm că $P$ e adevărată pentru toate expresiile care au un tip prin inducție asupra definiției relației de tip.
\end{proof}
\end{frame}


\begin{frame}{Proprietatea de a progresa a sistemului de tipuri}
\only<beamer>{
\begin{theorem} Dacă $\tjud{e}{T}$ și $\Dom(\Gamma) \subseteq \Dom(s)$ atunci $e$ este valoare sau există $e'$, $s'$ astfel încât $\Ss{\c{e,s}}{\c{e',s'}}$.
\end{theorem}}
\begin{block}{Lemă}
Dacă $\tjud{e}{T}$ și $e$ este valoare, atunci 
\begin{description}
\item[Dacă $T = {\Sint}$] atunci există $n$ întreg astfel încât $e = n$
\item[Dacă $T = {\Sbool}$] atunci $e = \Strue$ sau $e = \Sfalse$
\item[Dacă $T = {\Sunit}$] atunci $e = {\Sskip}$
\end{description}
\end{block}
\end{frame}

\begin{frame}{Reguli pentru tipuri}{}

$\reg[tN]{\tjud{n}{\Sint}}{}{n \in \mathbb{Z}}$

\vfill$\reg[tB]{\tjud{b}{\Sbool}}{}{b\in \{\Strue,\Sfalse\}}$

\vfill$\reg[t+]{\tjud{e_1 + e_2}{\Sint}}{\tjud{e_1}{\Sint} \si \tjud{e_2}{\Sint}}{}$
\hfill
$\reg[t$\leq$]{\tjud{e_1 \terminal{<=} e_2}{\Sbool}}{\tjud{e_1}{\Sint} \si \tjud{e_2}{\Sint}}{}$

\vfill$\reg[tIf]{\tjud{\Sif e_1 \Sthen e_2 \Selse e_3}{{T}}}{\tjud{e_1}{\Sbool} \si \tjud{e_2}{{T}} \si \tjud{e_3}{{T}}}{}$

\vfill$\reg[tAtrib]{\tjud{l\terminal{:=}e}{\Sunit}}{\tjud{e}{\Sint}}{\Gamma(l) = \Sintref}$

\vfill$\reg[tLoc]{\tjud{!l}{int}}{}{\Gamma(l) = \Sintref}$

\vfill$\reg[tSkip]{\tjud{\Sskip}{\Sunit}}{}{}$

\vfill$\reg[tSecv]{\tjud{e_1\terminal{;} e_2}{T}}{\tjud{e_1}{\Sunit}\si \tjud{e_2}{T}}{}$

\vfill$\reg[tWhile]{\tjud{\Swhile e_1 \Sdo e_2 \Sdone}{\Sunit}}{\tjud{e_1}{\Sbool} \si \tjud{e_2}{\Sunit}}{}$
\end{frame}


\begin{frame}<handout:0>{Definiția sistemului de tranziție pentru limbajul IMP}
$\reg[+]{\Ss{\c{n_1 + n_2,\stare}}{\c{n,\stare}}}{}{n = n_1 + n_2}$
$\reg[$\leq$]{\Ss{\c{n_1 \terminal{<=} n_2,\stare}}{\c{b,\stare}}}{}{b = (n_1 \leq n_2)}$

\vfill { $\reg[OpS]{\Ss{\c{e_1 \mathrel{o} e_2,\stare}}{\c{e_1' \mathrel{o} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$\hfill
$\reg[OpD]{\Ss{\c{n_1 \mathrel{o} e_2,\stare}}{\c{n_1 \mathrel{o} e_2',\stare'}}}{\Ss{\c{e_2,\stare}}{\c{e_2',\stare'}}}{}$}

\vfill $\reg[Loc]{\Ss{\c{\terminal{!} l,\stare}}{\c{n, \stare}}}{}{l\in\Dom(\stare), n = \stare(l)}$
$\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$

\vfill$\reg[AtribD]{\Ss{\c{l \terminal{:=} e ,\stare}}{\c{l \terminal{:=} e' ,\stare'}}}{\Ss{\c{e,\stare}}{\c{e',\stare'}}}{}$

$\reg[Secv]{\Ss{\c{\Sskip \terminal{;} e_2,\stare}}{\c{e_2,\stare}}}{}{}$
$\reg[SecvS]{\Ss{\c{e_1 \terminal{;} e_2},\stare}{\c{e_1' \terminal{;} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$


\vfill $\reg[IfTrue]{\Ss{\c{\Sif  {\terminal{true}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_1,\stare}}}{}{}$ 
$\reg[IfFalse]{\Ss{\c{\Sif {\terminal{false}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_2,\stare}}}{}{}$ 
$\reg[IfS]{
 \Ss{\c{\Sif {e} \Sthen e_1 \Selse e_2,\stare}}{\c{\Sif  {e'} \Sthen e_1 \Selse e_2,\stare'}}
}{
  \Ss{\c{e,\stare}}{\c{e',\stare'}}
}
{}$

\vfill $\reg[While]{\Ss{\c{\Swhile {e_1} \Sdo e_2 \Sdone{},\stare}}{}}{}
{}$

\hfill $\c{\Sif {e_1} \Sthen (e_2\terminal{;} {\Swhile {e_1} \Sdo e_2 \Sdone}) \Selse  {\Sskip},\stare}$

\end{frame}

\end{subsection}

\begin{subsection}{Inducție deductivă pe definiția sistemului de tranziție}

\begin{frame}{Proprietatea de conservare a tipului}

\begin{theorem}
Dacă $\tjud{e}{T}$, $\Dom(\Gamma) \subseteq \Dom(s)$ și $\Ss{\c{e,s}}{\c{e',s'}}$, \\atunci 
$\tjud{e'}{T}$ și $\Dom(\Gamma) \subseteq \Dom(s')$.
\end{theorem}

\begin{proof}[Idee de demonstrație]
 Fie $P$ proprietatea definită de 

\(P(\Ss{\c{e,s}}{\c{e',s'}}) \stackrel{def}{=} \forall \Gamma,T.\)
\[\tjud{e}{T} \wedge \Dom(\Gamma)\subseteq\Dom(s) \implies \tjud{e'}{T} \wedge \Dom(\Gamma)\subseteq\Dom(s') 
\]

Demonstrăm că $P$ e adevărată pentru întreg sistemul de tranziție asociat semanticii IMP prin inducție asupra definiției sistemului de tranziție.
\end{proof}

\end{frame}

\begin{frame}{Definiția sistemului de tranziție pentru limbajul IMP}
$\reg[+]{\Ss{\c{n_1 + n_2,\stare}}{\c{n,\stare}}}{}{n = n_1 + n_2}$
$\reg[$\leq$]{\Ss{\c{n_1 \terminal{<=} n_2,\stare}}{\c{b,\stare}}}{}{b = (n_1 \leq n_2)}$

\vfill { $\reg[OpS]{\Ss{\c{e_1 \mathrel{o} e_2,\stare}}{\c{e_1' \mathrel{o} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$\hfill
$\reg[OpD]{\Ss{\c{n_1 \mathrel{o} e_2,\stare}}{\c{n_1 \mathrel{o} e_2',\stare'}}}{\Ss{\c{e_2,\stare}}{\c{e_2',\stare'}}}{}$}

\vfill $\reg[Loc]{\Ss{\c{\terminal{!} l,\stare}}{\c{n, \stare}}}{}{l\in\Dom(\stare), n = \stare(l)}$
$\reg[Atrib]{\Ss{\c{l \terminal{:=} n,\stare}}{\c{\Sskip,\stare[l \mapsto n]}}}{}{l\in\Dom(\stare)}$

\vfill$\reg[AtribD]{\Ss{\c{l \terminal{:=} e ,\stare}}{\c{l \terminal{:=} e' ,\stare'}}}{\Ss{\c{e,\stare}}{\c{e',\stare'}}}{}$

$\reg[Secv]{\Ss{\c{\Sskip \terminal{;} e_2,\stare}}{\c{e_2,\stare}}}{}{}$
$\reg[SecvS]{\Ss{\c{e_1 \terminal{;} e_2},\stare}{\c{e_1' \terminal{;} e_2,\stare'}}}{\Ss{\c{e_1,\stare}}{\c{e_1',\stare'}}}{}$


\vfill $\reg[IfTrue]{\Ss{\c{\Sif  {\terminal{true}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_1,\stare}}}{}{}$ 
$\reg[IfFalse]{\Ss{\c{\Sif {\terminal{false}} \Sthen e_1 \Selse e_2,\stare}}{\c{e_2,\stare}}}{}{}$ 
$\reg[IfS]{
 \Ss{\c{\Sif {e} \Sthen e_1 \Selse e_2,\stare}}{\c{\Sif  {e'} \Sthen e_1 \Selse e_2,\stare'}}
}{
  \Ss{\c{e,\stare}}{\c{e',\stare'}}
}
{}$

\vfill $\reg[While]{\Ss{\c{\Swhile {e_1} \Sdo e_2 \Sdone{},\stare}}{}}{}
{}$

\hfill $\c{\Sif {e_1} \Sthen (e_2\terminal{;} {\Swhile {e_1} \Sdo e_2 \Sdone}) \Selse  {\Sskip},\stare}$

\end{frame}

\end{subsection}


\begin{frame}{Proprietatea de siguranță a sistemului de tipuri}
{programele bine formate nu se împotmolesc}
\begin{theorem}
Dacă $\tjud{e}{T}$, $\Dom(\Gamma) \subseteq \Dom(s)$ și ${\c{e,s}}\longrightarrow^\ast{\c{e',s'}}$, atunci $e'$ este valoare sau există $e''$, $s''$ astfel încât $\Ss{\c{e',s'}}{\c{e'',s''}}$.
\end{theorem}


\begin{proof}[Idee de demonstrație]
 Fie $P$ proprietatea definită de 
\(P(k) \stackrel{def}{=} \forall \Gamma,e,T,s,e',s'. \)
\(\tjud{e}{T} \wedge \Dom(\Gamma)\subseteq\Dom(s) \wedge {\c{e,s}}\longrightarrow^k{\c{e',s'}} \implies \tjud{e'}{T} \wedge \Dom(\Gamma)\subseteq\Dom(s')\)
\begin{itemize}
\item Demonstrăm că $P$ e adevărată pentru orice număr natural $k$ prin inducție asupra lui $k$ 
\begin{itemize}
\item Folosim Prop. de conservare pentru pasul de inducție.
\end{itemize}
\item Aplicăm Prop. de progres lui $\c{e',s'}$ din ipoteza teoremei.
\end{itemize}
\end{proof}

\end{frame}

\begin{frame}{Tehnici de demonstrație}{Rezumat}
\begin{description}
\item[Determinism] Inducție structurală pe definiția expresiilor \structure{e}
\item[Progres] Inducție deductivă pe definiția relației de tip \structure{$\tjud{e}{T}$}
\item[Conservarea tipurilor] Inducție deductivă pe definiția sistemului de tranziție \structure{$\Ss{\c{e',s'}}{\c{e'',s''}}$}
\item[Siguranță] Inducție matematică pe lungimea secvenței de tranziții \structure{$\longrightarrow^k$}
\end{description}

\begin{block}{Cum alegem pe ce facem inducție?}
Cu grijă... în general alegem metoda cea mai la îndemână, încercăm să rescriem proprietatea pentru a vedea ce se cuantifică universal.
\end{block}
\end{frame}

%
%%\begin{frame}{Inducție deductivă}{Exemplu}
%%\begin{theorem}[Corespondență între semantica naturală și mașina SMC]
%%Dacă $\S{\c{e,s}}{n}$ atunci $\c{e\cdot c, r, s} \longrightarrow^\ast \c{c, n\cdot r, s}$.
%%\end{theorem}
%%\begin{block}{Demonstrație (inducție deductivă asupra relației $\S{}{}$)}
%%  \begin{description} 
%%     \item[$\reg{\S{\c{n,s}}{n}}{}{n \mbox{ întreg}}$:] $\c{n \cdot c, r, s} \xrightarrow{\mbox{IntCt}} \c{c, n\cdot r, s}$ 
%%    \item[$\reg{\S{\c{{\mathrel{!} l},s}}{n}}{}{l \mbox{ locație, cu $l\in Dom(s)$ și $s(l)=n$}}$ :] 
%%$\c{{\mathrel{!} l} \cdot c, r, s} \xrightarrow{\mbox{Loc}} \c{c, n\cdot r, s}$ 
%%    \item[$\reg{\S{\c{e_1\mathrel{o} e_2,s}}{n}}{\S{\c{e_1,s}}{n_1}\si \S{\c{e_2,s}}{n_2}}{o \mbox{ operație întreagă și $n = n_1 \mathrel{o} n_2$}}$ :]
%%
%%     \item[]\vspace{-1ex}$\begin{array}{l}
%%  \c{e_1\mathrel{o} e_2 \cdot c, r, s} \xrightarrow{\mbox{IntOpC}} \c{e_1 \cdot e_2 \cdot o \cdot c, r, s} \xrightarrow{\mbox{ip. ind}}
%%\\
%%  \c{e_2 \cdot o \cdot c, n_1 \cdot r, s}  \xrightarrow{\mbox{ip. ind}}   \c{o \cdot c, n_2 \cdot n_1 \cdot r, s}  \xrightarrow{\mbox{IntOp}}
%%\\
%%   \c{c, n \cdot r, s}
%%\end{array} $
%%  \end{description}
%%\end{block}
%%\end{frame}
\end{section}


\end{document}



