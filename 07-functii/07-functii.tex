\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}

\title[SLP---Funcții]{$\Sfun$-IMP}
\subtitle{Funcții}
\begin{document}
\maketitle

\begin{section}{Funcții/proceduri/subrutine}

 \lstset{
               language=Caml,
               basicstyle=\small,
               tabsize=2,
               %frame=tb,
               columns=flexible,
               mathescape=false,
	      upquote=true,
    }
\begin{frame}[fragile]{Exemple}{Adunare și incrementare ca funcții de ordinul I}
\begin{block}{C/C++/\ldots}
\begin{asciic}
int addition(int x, int y) { return x+y; }
int increment(int x) { return x+1; }
\end{asciic}
\end{block}

\begin{block}{Javascript}
\begin{asciijs}
function addition(x,y) { return x + y; }
function increment(x) { return x + 1; }
\end{asciijs}
\end{block}

\begin{block}{OCaml}
\begin{asciiml}
let addition = fun (x,y) -> x + y
let increment = fun x -> x + 1
\end{asciiml}
\end{block}

\end{frame}

\begin{frame}[fragile]{Exemple}{Stil funcțional}

\begin{description}
\item[Javascript]
\begin{asciijs}
addition = function (x) { return function(y) { return x+y; } }
increment = addition (1)
\end{asciijs}

\item[OCaml]
\begin{asciiml}
let adddition = fun x -> fun y -> x+y
let increment = addition 1
\end{asciiml}

\item[C++]
\begin{asciic}
#include<iostream>
using namespace std;
int main()
{
    auto plusFn = [] (int x) { return [x] (int y) {return x+y;};};
    auto inc = plusFn(1);
    cout << inc(3) << endl;
}
\end{asciic}
\end{description}
\end{frame}

\begin{frame}[fragile]{Exemple}{Instanțiere parțială a argumentelor în C++}
\begin{asciic}
#include <iostream>
#include <functional>
using namespace std;
using namespace std::placeholders;

int plusFn(int x,int y) {return x+y;}

int main()
{
    auto inc = bind(plusFn,_1,1);
    cout << inc(3) << endl;
}
\end{asciic}
\end{frame}


\begin{frame}[fragile]{Exemple}{Capturarea variabilelor din mediu în C++}
\begin{asciic}
#include <iostream>
#include <array>
#include <functional>
using namespace std;

int main() {
    array<function<int()>,11> funcs;
    for (auto i = 0; i < 11; i++) {
    	funcs[i] = [i]() {return i;};
    }
    for (auto f : funcs) {
    	cout << f() << endl;
    }
}
\end{asciic}
\end{frame}

\begin{frame}[fragile]{Exemple}{Capturarea variabilelor din mediu în C++}
\begin{asciic}
#include <iostream>
#include <array>
#include <functional>
using namespace std;

int main() {
    array<function<int()>,11> funcs;
    for (auto i = 0; i < 11; i++) {
    	funcs[i] = [&i]() {return i;};
    }
    for (auto f : funcs) {
    	cout << f() << endl;
    }
}
\end{asciic}
\end{frame}



\begin{frame}[fragile]{Exemple}{Capturarea variabilelor de mediu în Javascript}
\begin{asciijs}
var bar = function (x) { 
  return function() { var x = 5; return x; }; 
}
var f = bar(200);
f()
\end{asciijs}
\end{frame}

\begin{frame}[fragile]{Domeniul de vizibilitate al variabilelor}{C\#}
\begin{asciics}
class P {
    public static void Main() {
        int i = 7 ;
        System.Console.WriteLine(i);
        {
          System.Console.WriteLine(i);
          int i = 13 ;
          System.Console.WriteLine(i);
        }
        System.Console.WriteLine(i);
    }
}
\end{asciics}
\end{frame}

\begin{frame}[fragile]{Domeniul de vizibilitate al variabilelor}{C++}
\begin{asciic}
#include <iostream>
using namespace std;
int main()  {
  int i = 7;
  cout << i << endl;
  {
     cout << i << endl;
     int i = 13;
     cout << i << endl;
  }
  cout <<i << endl;
}
\end{asciic}
\end{frame}


\end{section}

\begin{section}{$\Sfun$-IMP}
\begin{frame}[fragile]{Funcții + IMP = $\Sfun$-IMP}{Exemple}
\begin{asciiml}
fun (x) -> x+1

(fun (x) -> x+1) 7

fun (x) -> fun (y) -> x + y

(fun (x) -> fun (y) -> x + y) 1

fun (x) -> fun (y) -> x (x y)

(fun (x) -> fun (y) -> x (x y)) (fun (x) -> x+1)

((fun (x) -> fun (y) -> x (x y)) (fun (x) -> x+1)) 7
\end{asciiml}
\end{frame}


\begin{frame}[fragile]{\only<beamer>{$\Sfun$-IMP}}{Sintaxă --- Totul este o expresie}
\vspace{-5ex}\begin{syntaxBlock}{\Exp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid\Bool \Smid \Exp\iop \Exp \Smid\Exp\bop \Exp \Smid \Sif\Exp\Sthen \Exp\Selse\Exp}{}
\syntaxCont{\Sskip \Smid  \Exp\terminal{;}\Exp \Smid \Swhile \Exp\Sdo \Exp}{}
\syntaxCont{\Sref \Exp \Smid \terminal{!}\Exp \Smid \Exp \terminal{:=} \Exp}{}
\syntaxCont{\alert{\structure{x}\Smid \Sfun (\structure{x})\ \lstinline$->$\ \Exp\Smid \Exp \mathrel{} \Exp}}{}
%\item[]\renewcommand{\defSort}{\Id}
%\syntax{\mbox{locație de memorie}}{} 
%\\
\renewcommand{\defSort}{\Int}
\syntax{\mbox{număr întreg}}{}
\\
\renewcommand{\defSort}{\Bool}
\syntax{\Strue \mid \Sfalse}{}
\\
\renewcommand{\defSort}{\iop}
\syntax{\mbox{operație binară cu rezultat întreg}}{}
\renewcommand{\defSort}{\bop}
\syntax{\mbox{operație binară cu rezultat boolean}}{}
\renewcommand{\defSort}{\structure{x}}
\syntax{\mbox{\alert{variabilă dintr-o mulțime infinită}}}{}
\end{itemize}
}
\end{syntaxBlock}
\end{frame}

\begin{frame}[fragile]{Un program corect sintactic}
\begin{asciiml}
suma := (fun (x) -> 
               if x <= 0 
               then 0 
               else x + (! suma) (x - 1)
         ) ;
y := suma(5) + suma(6)
\end{asciiml}

\onslide<2>
\begin{block}{Eventuale probleme}
\begin{itemize}
\item Vrem să stocăm în memorie o „funcție“
\item Folosim variabila care stochează funcția în corpul funcției
\end{itemize}
\end{block}
\end{frame}
\end{section}

\begin{section}{Evaluarea funcțiilor}
\begin{frame}{Evaluarea funcțiilor ca substituție}
\begin{itemize}
\item Dată fiind $f : \mathbb{N} \longrightarrow \mathbb{N}$, $f(x) = x * x$, simplificăm  $f(y+5)$  înlocuind în definiția funcției $f$ variabila $x$ cu valoarea dată $y+5$
\[f(y + 5) = (y + 5) * (y + 5)\] 
\vitem Folosind ideea de substituție, $f(y + 5) = (x * x)[(y + 5) / x]$
\item Unde $e[e' / x]$ se definește \alert{intuitiv} ca fiind expresia $e$ în care \structure{aparițiile libere} ale lui $x$ se înlocuiesc cu $e'$.
\end{itemize}
\end{frame}
\begin{subsection}{Variabile libere}
\begin{frame}[fragile]{Terminologie}{Apariții libere, apariții legate}
\begin{block}{ \lstinline$fun (x) -> e$}
\begin{itemize}
\item \structure{fun} e un \structure{operator de legare}
\begin{itemize}
\item Asemănator cuantificatorilor ($\exists, \forall$) din logică
\end{itemize}
\item \structure{$x$} se numește variabila legată de \lstinline$fun$
\item \structure{$e$} se numește \structure{domeniul} legării lui $x$
\item O apariție a lui $x$ în domeniul unei legări a lui $x$ se numește \structure{legată}.
\[\fun{\structure<2->{x}}{\alert<3>{y} * \fun{\structure<2->{y}}{\structure<2->{x} + \structure<2->{y}}}\]
\item O variabilă este legată de operatorul $\lambda$ cel mai apropiat care o leagă.
\[\fun{x}{\fun{\structure<2->{x}}{\structure<2->{x}}}\]
\item Aparițiile nelegate se numesc \alert{libere}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Variabile libere}{Definiție formală}
Funcția $\var$ care dă mulțimea variabilelor libere ale unei expresii e definită recursiv pe structura expresiilor:
\begin{itemize}
\item \structure{$\var(x) = \{x\}$}
\item \structure{$\var(\fun{x}{e}) = \var(e) \setminus \{x\}$}
\item \structure{$\var(e_1 \terminal{} e_2) = \var(e_1) \cup \var(e_2)$}
\item $\var(n) = \var(b) = \var(\Sskip) = \emptyset$
\item $\var(e_1 \mathrel{o} e_2) = \var(e_1) \cup \var(e_2)$, $o\in {iop}\cup {bop}$
\item $\var(\Sif e_b \Sthen e_1 \Selse e_2) = \var(e_b) \cup\var(e_1) \cup\var(e_2)$
\item $\var(e_1 \terminal{;} e_2) = \var(e_1) \cup \var(e_2)$
\item $\var(\Swhile e_b \Sdo e) = \var(e_b) \cup \var(e)$
\item $\var(\Sref e) = \var(\terminal{!} e) = \var(e)$
\item $\var(e_1 \terminal{:=} e_2) = \var(e_1) \cup \var(e_2)$
\end{itemize}
\end{frame}
\end{subsection}
\begin{subsection}{Substituție}
\begin{frame}{\only<beamer|handout>{Substituție}}{Exemple}
\begin{block}{Definiția intuitivă a substituției}
$e[e' / x]$ se obține prin înlocuirea cu $e'$ a tuturor aparițiilor libere ale lui $x$ în $e$
\end{block}

\vfill
\begin{itemize}
\item $(\fun{x}{x + y})[4/y]\only<2->{=\fun{x}{x + 4}}$
\item<2-> $(\fun{x}{x + y})[4/x]\only<3->{=\fun{x}{x + y}}$
\begin{itemize}
\item<3-> Deoarece $x$ nu apare liber
\end{itemize}
\item<3-> $(\fun{x}{x + y})[x/y]\only<4->{\not=\fun{\structure{x}}{\structure{x} + \alert{x}}}$
\begin{itemize}
\item<4-> Deoarece variabila $\alert{x}$ ar fi \structure{capturată} (incorect) de operatorul de legare.
\end{itemize}
\item<5-> $(\fun{x}{x + y})[x/y] \equiv (\fun{z}{z + y})[x/y] = \fun{z}{z + x}$
\end{itemize}
\end{frame}

\begin{frame}{Definiție formală (inductivă)}
\begin{itemize}
\item[] $\displaystyle\reg{x[e' / y] = e'}{}{x = y}$ \hfill și \hfill
 $\displaystyle\reg{x[e' / y] = x}{}{x \neq y}$
\vitem[] $\displaystyle\reg{n[e' / y] = n}{}{}$
 \hfill La fel și pentru $b$, $l$, și $\Sskip$
\vitem[] $\displaystyle\reg{(e_1\mathrel{} e_2)[e' / y] = e_1'\mathrel{} e_2'}{e_1[e'/y] = e_1' \si e_2[e'/y] = e_2'}{}$  
\\La fel și pentru ceilalți constructori de limbaj, mai puțin $\Sfun$ 
\vitem[]  $\displaystyle\reg{(\fun{x}{e})[e' / y] = \fun{x}{e}}{}{x = y}$ 
\vitem[] $\displaystyle\reg{(\fun{x}{e})[e' / y] = \fun{x}{e''}}{e[e'/y] = e''}{x \not \in \var(e')\cup \{y\}}$
\end{itemize}
\onslide<2>\alert{Și dacă $x \in  \var(e')$?}
\end{frame}
\end{subsection}

\begin{subsection}{$\alpha$-echivalență}


\begin{frame}{Substituție}{Evitarea capturării variabilelor}
$\displaystyle\reg{(\fun{x}{e})[e' / y] = \fun{x'}{e'''}}{e[x'/x] = e'' \si e''[e'/y] = e'''}{}$

\hfill dacă $x \in \var(e')\setminus \{y\}, x' \not\in \var(e')\cup\{y\}$

\end{frame}

\begin{frame}{$\alpha$-echivalență}
\begin{block}{Definiție intuitivă}
O variabilă $\alert{x}$ legată de $\fun{\alert{x}}{e}$ poate fi redenumită împreună cu toate aparițiile legate de ea.
\[\fun{x}{x + y} \equiv_\alpha \fun{z}{z + y}\] 
\end{block}
\end{frame}



\begin{frame}{Definiție inductivă}
\begin{itemize}
\item[] $\displaystyle\reg[R]{e \equiv_\alpha e}{}{}$ \hfill \;\hfill  $\displaystyle\reg[S]{e' \equiv_\alpha e}{e \equiv_\alpha e'}{}$ \hfill\;\hfill $\displaystyle\reg[T]{e \equiv_\alpha e''}{e \equiv_\alpha e' \si e'  \equiv_\alpha e'' }{}$\hfill\;
\vitem[] $\displaystyle\reg{(e_1\mathrel{} e_2) \equiv_\alpha e_1'\mathrel{} e_2'}{e_1 \equiv_\alpha  e_1' \si e_2 \equiv_\alpha e_2'}{}$  
\\La fel și pentru ceilalți constructori de limbaj, mai puțin $\Sfun$ 

\vitem[]
$\displaystyle\reg{\fun{x}{e} \equiv_\alpha \fun{x}{e'}}{e \equiv_\alpha e'}{}$

\vitem[]
$\displaystyle\reg{\fun{x}{e} \equiv_\alpha \fun{y}{(e[y/x])}}{}{y\not\in\var(e)}$
\end{itemize}
\end{frame}

\begin{frame}{Propietăți de compatibilitate}
\begin{block}{Compatibilitate cu substituția}
\[e_1 \equiv_\alpha e_1'  \mbox{ și } e_2 \equiv_\alpha e_2' \implies e_1[e_2/x] \equiv_\alpha e_1'[e_2'/x]\]
\end{block}

\begin{block}{Substituția e funcțională modulo $\alpha$-echivalență}
\[e[e'/x] = e_1 \mbox{ și } e[e'/x] = e_2 \implies e_1 \equiv_\alpha e_2\]
\end{block}


\vfill\begin{block}{Compatibilitate cu $\var$}
\[e \equiv_\alpha e'  \implies \var(e) = \var(e')\]
\end{block}
\end{frame}

\begin{frame}{Termeni $\Sfun$-IMP}
  \begin{block}{Definiție}
    Un termen $\Sfun$-IMP este o clasă de echivalență modulo $\equiv_\alpha$.
  \end{block}

\vfill
\begin{itemize}
\item Identificăm termenii obținuți prin redenumirea variabilelor legate
\item Simplificare: notăm clasa de echivalență prin oricare din reprezentanți.
\end{itemize}
\end{frame}

\end{subsection}
\end{section}

\begin{section}{Semantică de evaluare pentru $\Sfun$-IMP}

\begin{frame}{\only<beamer|handout>{Semantică de evaluare pentru $\Sfun$-IMP}}
 Relație defnită inductiv, de forma 
\[ \S{\c{e,\sigma}}{\c{v,\sigma'}}\]
unde:
\begin{itemize}
\item $e$ și $v$ sunt termeni $\Sfun$-IMP \structure{închiși}, i.e., $\var(e) = \var(v) = \emptyset$
\item $\sigma$ și $\sigma'$ sunt stări (funcții parțiale de la locații la numere întregi)
\item $v$ este o valoare 
\begin{syntaxBlock}{\structure{v}}
\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid \Bool \Smid \Loc \Smid \Sskip \Smid \fun{\structure{x}}{\Exp}}{}
\end{syntaxBlock}
\end{itemize}
\end{frame}

\begin{frame}
{Expresii}
\begin{itemize}
\item[] $\reg[val]{\S{\c{v,\sigma}}{\c{v,\sigma}}}{}{v \mbox{ valoare}}$

\vitem[]
$\reg[op]{\S{\c{e_1\mathrel{o} e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{n_1, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{n_2, \sigma_2}}}{v = n_1 \mathrel{o} n_2}$

\vitem[]
$\reg[if-true]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_1}}}{\S{\c{e_b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{e_1,\sigma'}}{\c{v, \sigma_1}}}{}$

\vitem[]
$\reg[if-false]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_b,\sigma}}{\c{\Sfalse, \sigma'}}\si \S{\c{e_2,\sigma'}}{\c{v, \sigma_2}}}{}$

\end{itemize}
\end{frame}

\begin{frame}
{Memorie}
\begin{itemize}
\item[]
$\reg[ref]{\S{\c{{\Sref e},\sigma}}{\c{l,\sigma''}}}{\S{\c{e,\sigma}}{\c{v,\sigma'}}}{l \mbox{ locație, $l\not\in Dom(\sigma)$ și $\sigma'' = \sigma'[l \mapsto v]$}}$

\vitem[]
$\reg[!]{\S{\c{{\mathrel{!} e},\sigma}}{\c{v,\sigma'}}}{\S{\c{e,\sigma}}{\c{l,\sigma'}}}{l \mbox{ locație, $l\in Dom(\sigma')$ și $\sigma'(l)=v$}}$

\vitem[]
$\reg[asgn]{\S{\c{{e_1\mathrel{:=} e_2},\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{e_1,\sigma}}{\c{l,\sigma_1}} \si \S{\c{e_2,\sigma_1}}{\c{v,\sigma_2}}}{\sigma' = \sigma_2[ l \mapsto v]}$

\end{itemize}
\end{frame}

\begin{frame}
{Compunere secvențială și $\Swhile$}

\vfill$\reg[seq]{\S{\c{e_1\mathrel{;} e_2,\sigma}}{\c{\Sskip,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{\Sskip, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{\Sskip, \sigma_2}}}{}$
\vfill
$\reg{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'''}}}{\S{\c{b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{c,\sigma'}}{\c{\Sskip, \sigma''}}\si \S{\c{\Swhile b \Sdo c,\sigma''}}{\c{\Sskip,\sigma'''}}}{}$

\hfill ({\sc while-true})

\vfill
$\reg[while-false]{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{b,\sigma}}{\c{\Sfalse, \sigma'}}}{}$

\vfill

\end{frame}

\begin{subsection}{Semantica aplicării funcțiilor}

\begin{frame}[fragile]{Evaluarea funcțiilor}
Fie expresia $e$ dată de 
\begin{asciiml}
(fun (x) -> l := 5 ; x ; x) (l := !l + 1)
\end{asciiml}

Care este starea finală corespunzătoare stării inițiale $\c{e,\{l\mapsto 0\}}$?
\[\c{e,\{l\mapsto 0\}} \longrightarrow^\ast \c{\Sskip, \{l\mapsto \alert{???}\}}\]

\end{frame}



\begin{frame}{Evaluare strictă (Cam toate limbajele care au efecte laterale)}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție
$\fun{x}{e}$
\item Apoi reducem $e_2$ până la o valoare $v$
\item Apoi reducem $(\fun{x}{e})\mathrel{}v$ la $\substapp{e}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}

\onslide<2>
\[\begin{array}{ll}
& \c{(\fun{x}{l := 5 ; x ; x}) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(\fun{x}{l := 5 ; x ; x}) (l := 0 + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(\fun{x}{l := 5 ; x ; x}) (l := 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(\fun{x}{l := 5 ; x ; x}) \Sskip, \{l \mapsto 1\}} \\
\rightarrow& \c{l := 5 ; \Sskip ; \Sskip, \{l \mapsto 1\}} \\
\rightarrow& \c{\Sskip ; \Sskip ; \Sskip, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; \Sskip, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 5\}} \\
\end{array}\]

\end{frame}


\begin{frame}{Evaluare non-strictă (Limbaje pur funcționale)} 
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție $\fun{x}{e}$
\item Apoi reducem $(\fun{x}{e}) \mathrel{}e_2$ la $\substapp{e}{\subst{\substpair{e_2}{x}}}$
\end{itemize}
\end{block}

\onslide<2>\hfill $\begin{array}{ll}
& \c{(\fun{x}{l := 5 ; x ; x}) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{l := 5 ; l := !l + 1 ; l := !l + 1, \{l \mapsto 0\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 5 + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 6 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 6 + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 7, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 7\}}
\end{array}$ \hfill\;

\end{frame}

\begin{frame}{Evaluare leneșă}{Implementări ale limbajelor pure gen Haskell}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reduc $e_1$ până la o funcție
$\fun{x}{e}$
\item Apoi reduc corpul funcției \structure{e} până la un $e'$ care are nevoie de $x$
\item Apoi reduc $e_2$ până la o valoare $v$
\item Apo reduc $(\fun{x}{e'})\mathrel{} v$ la $\substapp{e'}{\subst{\substpair{v}{x}}}$

\end{itemize}
\end{block}
\onslide<2>\hfill $\begin{array}{ll}
& \c{(\fun{x}{l := 5 ; x ; x}) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(\fun{x}{\Sskip ; x ; x}) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{x ; x}) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{x ; x}) (l := 5 + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{x ; x}) (l := 6), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{x ; x}) \Sskip, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip ; \Sskip, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 6\}} \\
\end{array}$ \hfill\;

\end{frame}


\begin{frame}{Evaluare nerestricționată}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem fie $e_1$ fie $e_2$
\item Putem reduce corpurile funcțiilor
\item Oricând avem  $(\fun{x}{e'}) e''$, o putem (sau nu)
reduce la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\end{itemize} 
\end{block}
\end{frame}

\begin{frame}{Evaluare „normală“}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem mereu cel mai din stânga redex din cele de mai sus
\item Reducem $(\fun{x}{e'}) e''$ la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\item Reducem $e_1$ (putem reduce și corpurile funcțiilor)
\item Dacă $e_1\not\rightarrow$, reducem $e_2$
\end{itemize} 
\end{block}

\onslide<2>\hfill {\small$\begin{array}{ll}
& \c{(\fun{x}{l := 5 ; x ; x}) (l := !l + 1), \{l \mapsto 0\}} \\
\rightarrow& \c{(\fun{x}{\Sskip ; x ; x}) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{\Sskip ; x ; x}) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{(\fun{x}{x ; x}) (l := !l + 1), \{l \mapsto 5\}} \\
\rightarrow& \c{l := !l + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 5 + 1 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{l := 6 ; l := !l + 1, \{l \mapsto 5\}} \\
\rightarrow& \c{\Sskip ; l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := !l + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 6 + 1, \{l \mapsto 6\}} \\
\rightarrow& \c{l := 7, \{l \mapsto 6\}} \\
\rightarrow& \c{\Sskip, \{l \mapsto 7\}}
\end{array}$} \hfill\;
\end{frame}


\end{subsection}

\begin{subsection}{Reguli de reducție}


\begin{frame}{Evaluare strictă}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție
$\fun{x}{e}$
\item Apoi reducem $e_2$ până la o valoare $v$
\item Apoi reducem $(\fun{x}{e})\mathrel{}v$ la $\substapp{e}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}

\begin{overprint}
\onslide<1>
\begin{block}{Reguli (semantica evaluării)}
\[\reg[val]{\S{\c{e_1\mathrel e_2,\sigma}}{\c{v,\sigma'}}}{\S{\c{e_1,\sigma}}{\c{\fun{x}{e},\sigma_1}} \si \S{\c{e_2,\sigma_1}}{\c{v_2,\sigma_2}} \si \S{\c{e[v_2/x],\sigma_2}}{\c{v,\sigma'}}}{}\]

Notăm relația generată de ({\sc val}) și regulile din slide-urile precedente \structure{$\Downarrow_v$}. 
\end{block}
\onslide<2>
\begin{block}{Reguli (semantica tranzitională)}
\begin{itemize}
\item[]$\reg[S@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[S@D]{\Ss{\c{(\fun{x}{e_1})\mathrel{}e_2,s}}{\c{(\fun{x}{e_1})\mathrel{}e_2',s'}}}{\Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\item[]$\reg[S@]{\Ss{\c{(\fun{x}{e_1})\mathrel{}v_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{v_2}{x}}}}$
\end{itemize}
\end{block}
\end{overprint}
\end{frame}

\begin{frame}{Evaluare non-strictă} 
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reducem $e_1$ până la o funcție $\fun{x}{e}$ 
\item Apoi reducem $(\fun{x}{e}) \mathrel{}e_2$ la $\substapp{e}{\subst{\substpair{e_2}{x}}}$
\end{itemize}
\end{block}

\begin{overprint}
\onslide<2>
\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[NS@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[NS@]{\Ss{\c{(\fun{x}{e_1})\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\end{itemize}
\end{block}
\onslide<1>
\begin{block}{Reguli (semantica evaluării)}
\[\reg[num]{\S{\c{e_1\mathrel e_2,\sigma}}{\c{v,\sigma'}}}{\S{\c{e_1,\sigma}}{\c{\fun{x}{e},\sigma_1}} \si \S{\c{e[e_2/x],\sigma_1}}{\c{v,\sigma'}}}{}\]

Notăm relația generată de ({\sc num}) și regulile din slide-urile precedente \structure{$\Downarrow_n$}. 
\end{block}
\end{overprint}
\end{frame}

\begin{frame}{Putem/vrem să demonstrăm}

\[ \Downarrow_n \neq \Downarrow_v \]
\end{frame}

\begin{frame}{Evaluare nerestricționată}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem fie $e_1$ fie $e_2$
\item Putem reduce corpurile funcțiilor
\item Oricând avem  $(\fun{x}{e'}) e''$, o putem (sau nu)
reduce la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\end{itemize} 
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[NR@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{}$
\item[]$\reg[NR@D]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1\mathrel{}e_2',s'}}}{\Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\item[]$\reg[NRfunD]{\Ss{\c{\fun{x}{e},s}}{\c{\fun{x}{e'},s}}}{\Ss{\c{e,s}}{\c{e',s'}}}{}$
\item[]$\reg[NR@]{\Ss{\c{(\fun{x}{e_1})\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Evaluare „normală“}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$
\begin{itemize}
\item Reducem mereu cel mai din stânga redex din cele de mai sus
\item Reducem $(\fun{x}{e'}) e''$ la $\substapp{e'}{\subst{\substpair{e''}{x}}}$
\item Reducem $e_1$ (putem reduce și corpurile funcțiilor)
\item Dacă $e_1\not\rightarrow$, reducem $e_2$
\end{itemize} 
\end{block}

\begin{block}{Reguli}
\begin{itemize}
\item[]$\reg[Nor@]{\Ss{\c{(\fun{x}{e_1})\mathrel{}e_2,s}}{\c{e,s}}}{}{e = \substapp{e_1}{\subst{\substpair{e_2}{x}}}}$
\item[]$\reg[Nor@S]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1'\mathrel{}e_2,s'}}}{\Ss{\c{e_1,s}}{\c{e_1',s'}}}{e_1 \mbox{ nu e încă funcție}}$
\item[]$\reg[NorfunD]{\Ss{\c{\fun{x}{e},s}}{\c{\fun{x}{e'},s}}}{\Ss{\c{e,s}}{\c{e',s'}}}{}$
\item[]$\reg[Nor@D]{\Ss{\c{e_1\mathrel{}e_2,s}}{\c{e_1\mathrel{}e_2',s'}}}{\displaystyle \c{e_1,s}\not\rightarrow \si \Ss{\c{e_2,s}}{\c{e_2',s'}}}{}$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}{Evaluare leneșă}{Implementări ale limbajelor pure gen Haskell}
\begin{block}{}
Pentru a reduce $e_1 \mathrel{} e_2$:
\begin{itemize}
\item  Reduc $e_1$ până la o funcție
$\Sfun (x : T) \rightarrow e$
\item Apoi reduc corpul funcției \structure{e} până la un $e'$ care are nevoie de $x$
\item Apoi reduc $e_2$ până la o valoare $v$
\item Apo reduc $(\fun{x}{e'})\mathrel{} v$ la $\substapp{e'}{\subst{\substpair{v}{x}}}$
\end{itemize}
\end{block}
\begin{block}{Reguli?}
E mai complicat decât pare, deoarece trebuie să ne dăm seama că $e'$ are nevoie de $x$.
\end{block}

\end{frame}

\begin{frame}[fragile]{Fibonacci în Haskell}
\begin{asciimaude}
fibs = 0:1:zipWith (+) fibs (tail fibs)
fib n = fibs !! n
\end{asciimaude}
\end{frame}

\begin{frame}[fragile]{Numere prime în Haskell}{Ciurul lui Eratostene}
\begin{asciimaude}
primes = let { sieve (x:xs) = x : sieve [n | n <- xs, rem n x > 0] } 
           in sieve [2..] 
\end{asciimaude}
\end{frame}

\end{subsection}
%
%\begin{subsection}{Implementare --- Reprezentare De Buijn}
%\end{subsection}
%
\end{section}

%
%\begin{section}{Semantică operațională contextuală}
%\begin{frame}{Contexte de evaluare}
%  \begin{itemize}
%    \item Găsirea redex-ului se aseamănă cu un algoritm de analiză sintactică
%    \item Putem înlocui regulile structurale cu reguli gramaticale
%  \end{itemize}\small
%    \[\structure{\text{Sintaxă:\hspace{1em}}} e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}\]
%
%    \medskip
%  \begin{tabular}{ll}
%    \structure{Reguli structurale} 
%    & 
%    \structure{Contexte de evaluare} 
%    \\[1ex]
%        \begin{tabular}[t]{l} 
%          $\displaystyle\frac{\langle e_1, \sigma \rangle\longrightarrow\langle e'_1, \sigma \rangle}{\langle e_1 \mathrel{op} e_2, \sigma \rangle\longrightarrow\langle e'_1 \mathrel{op} e_2, \sigma \rangle}$ 
%          \\[4ex]
%          $\displaystyle\frac{\langle e_2, \sigma \rangle\longrightarrow\langle e'_2, \sigma \rangle}{\langle n_1 \mathrel{op} e_2, \sigma \rangle\longrightarrow\langle n_1 \mathrel{op} e'_2, \sigma \rangle}$ 
%        \end{tabular}\hspace{4em}
%          &
%        $\begin{array}[t]{rcl} 
%          c & \mathrel{::=} &\blacksquare
%          \\[1ex]
%         &  \mid & c \mathrel{op} e  
%          \\[1ex]
%          & \mid & n \mathrel{op} c 
%        \end{array}$
%      \end{tabular}
%  \vfill\begin{block}{Instanțierea unui context $c$ cu expresia $e$}
%      \[c[e] = c[e/\blacksquare]\]
%    \end{block}
%\end{frame}
%
%
%\begin{frame}{Contexte de evaluare}{Exemple}
%  \begin{description}
%    \item[Sintaxă:] $e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}$
%    \item[Contexte:] $c \mathrel{::=} {{\blacksquare} \mid {c \mathrel{op} e} \mid {n \mathrel{op} c}}$
%  \end{description}
%
%  \vfill
%  \begin{block}{Exemple de contexte}
%    \begin{tabular}{l@{\extracolsep{4em}}l}
%        \structure{Corecte} & \structure{Greșite}
%        \\
%        $\blacksquare$ & $5$
%        \\
%        $3 * \blacksquare$ & $x + \blacksquare$
%        \\
%        $9 + 3 * (\blacksquare + 7)$ & $3 * 3 + 3 * (\blacksquare + 7)$
%      \end{tabular}
%    \end{block}
%
%      \vfill
%      \begin{block}{Exemple de contexte instanțiate}
%        \begin{itemize}
%          \item $\blacksquare[x + 1] = x + 1$
%          \item $(9 + 3 * (\blacksquare + 7))[x] = 9 + 3 * (x + 7)$
%          \item $(9 + 3 * (\blacksquare + 7))[5] = 9 + 3 * (5 + 7)$
%        \end{itemize}
%      \end{block}
%\end{frame}
%
%
%\begin{frame}{Semantica Operațională Contextuală}
%{\cites{Felleisen, 1992}}
%  \begin{block}{Un pas de execuție folosind contexte de evaluare}
%    \begin{itemize}
%      \item Descompune expresia în contextul $c$ și redex-ul $r$
%      \item Aplică o regulă operațională asupra lui $r$ obținând $e$
%      \item Pune $e$ în contextul inițial, obținând $c[e]$
%%      \item Regulile structurale înlocuite de o \structure{singură} regulă de reducție globală
%    \[\frac{\langle r,\sigma \rangle \longrightarrow \langle e,\sigma \rangle}
%      {\langle c[r],\sigma \rangle \longrightarrow \langle c[e],\sigma \rangle}
%    \]
%      \end{itemize}
%  \end{block}
%  \begin{block}{Semantica: definiții de contexte și reguli de reducție}
%    \begin{description}
%    \item[Contexte:]   $c \mathrel{::=} {{\blacksquare} \mid {c \mathrel{op} e} \mid {n \mathrel{op} c}}$
%      \hfill \structure{Sintaxă:\ \ }
%    $e \mathrel{::=} {{n} \mid {l} \mid {e \mathrel{op} e}}$
%    \item[Reguli:] 
%      \begin{tabular}[t]{@{}l} 
%          $\langle l, \sigma\rangle \longrightarrow \langle n, \sigma \rangle \mbox{ \it dacă } n = \sigma(l)$
%          \\
%          $\langle n_1 \mathrel{op} n_2, \sigma\rangle \longrightarrow \langle n, \sigma \rangle \mbox{ \it dacă } n = n_1 \mathrel{op_{int}} n_2$
%        \end{tabular}
%    \end{description}
%  \end{block}
%\end{frame}
%
%\begin{frame}{Evaluare leneșă folosind Semantica Contextuală}{Idee de bază}
%\begin{block}{Contexte de evaluare pentru aplicație}
% \[\begin{array}{crl}
%c & \mathrel{::=} & {\blacksquare} \\
% & \mid & \ldots \\
% & \mid & c\; e\\
% & \mid & (\Sfun (x:T) \rightarrow c)\; e \\
% & \mid & (\Sfun (x:T) \rightarrow c[x])\; c 
%\end{array}
%\]
%\end{block}
%
%\begin{block}{Regulă de evaluare pentru aplicație}
% \[
%\Ss{\c{(\Sfun(x:T)\rightarrow c[x])\; v, s}}{\c{(\Sfun(x:T)\rightarrow c[v])\; v, s}}
%\]
%\end{block}
%
%
%\end{frame}
%
%
%\end{section}

%
%\begin{section}{Semantică de evaluare pentru FUN-IMP}
%
%\begin{frame}{\only<beamer|handout>{Semantică de evaluare pentru FUN-IMP}}
% Relație defnită inductiv, de forma 
%\[ \S{\c{e,\sigma}}{\c{v,\sigma'}}\]
%unde:
%\begin{itemize}
%\item $e$ și $v$ sunt termeni FUN-IMP \structure{închiși}, i.e., $\var(e) = \var(v) = \emptyset$
%\item $\sigma$ și $\sigma'$ sunt stări (funcții parțiale de la locații la numere întregi)
%\item $v$ este o valoare 
%\begin{syntaxBlock}{\structure{v}}
%\renewcommand{\syntaxKeyword}{}
%\syntax{\Int\Smid \Bool \Smid \Id \Smid \Sskip \Smid \lambda \structure{x} . \Exp}{}
%\end{syntaxBlock}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{Expresii}
%\begin{itemize}
%\item[] $\reg[val]{\S{\c{v,\sigma}}{\c{v,\sigma}}}{}{v \mbox{ valoare}}$
%
%\vitem[]
%$\reg[op]{\S{\c{e_1\mathrel{o} e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{n_1, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{n_2, \sigma_2}}}{v = n_1 \mathrel{o} n_2}$
%
%\vitem[]
%$\reg[if-true]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_1}}}{\S{\c{e_b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{e_1,\sigma'}}{\c{v, \sigma_1}}}{}$
%
%\vitem[]
%$\reg[if-false]{\S{\c{\Sif e_b \Sthen e_1 \Selse e_2,\sigma}}{\c{v,\sigma_2}}}{\S{\c{e_b,\sigma}}{\c{\Sfalse, \sigma'}}\si \S{\c{e_2,\sigma'}}{\c{v, \sigma_2}}}{}$
%
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{Memorie și compunere secvențială}
%\begin{itemize}
%\item[]
%$\reg[!]{\S{\c{{\mathrel{!} e},\sigma}}{\c{n,\sigma'}}}{\S{\c{e,\sigma}}{\c{l,\sigma'}}}{l \mbox{ locație, cu $l\in Dom(\sigma')$ și $\sigma'(l)=n$}}$
%
%\vitem[]
%$\reg[asgn]{\S{\c{{e_1\mathrel{:=} e_2},\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{e_1,\sigma}}{\c{l,\sigma_1}} \si \S{\c{e_2,\sigma_1}}{\c{n,\sigma_2}}}{\sigma' = \sigma_2[ l \mapsto n]}$
%
%\vitem[]
%$\reg[seq]{\S{\c{e_1\mathrel{;} e_2,\sigma}}{\c{\Sskip,\sigma_2}}}{\S{\c{e_1,\sigma}}{\c{\Sskip, \sigma_1}}\si \S{\c{e_2,\sigma_1}}{\c{\Sskip, \sigma_2}}}{}$
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%{While}
%
%\vfill
%$\reg{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'''}}}{\S{\c{b,\sigma}}{\c{\Strue, \sigma'}}\si \S{\c{c,\sigma'}}{\c{\Sskip, \sigma''}}\si \S{\c{\Swhile b \Sdo c,\sigma''}}{\c{\Sskip,\sigma'''}}}{}$
%
%\hfill ({\sc while-true})
%
%\vfill
%$\reg[while-false]{\S{\c{\Swhile b \Sdo c,\sigma}}{\c{\Sskip,\sigma'}}}{\S{\c{b,\sigma}}{\c{\Sfalse, \sigma'}}}{}$
%
%\vfill
%
%\end{frame}
%
%\end{subsection}
%
%\begin{frame}{Putem/vrem să demonstrăm}
%
%\[ \Downarrow_n \neq \Downarrow_v \]
%\end{frame}
%
%\end{section}

\end{document}