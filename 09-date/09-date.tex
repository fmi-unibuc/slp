\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}


\title[SLP---Tipuri de date]{DATA-IMP}
\subtitle{$\Sfun$-IMP + date structurate}
\begin{document}
\maketitle

%\begin{section}{Referințe}
%\begin{frame}{Referințe}{Sintaxă}
%\begin{syntaxBlock}{\Exp}
%\alert{
%\begin{itemize}
%\item[]\renewcommand{\syntaxKeyword}{}
%\syntax{\ldots}{}
%\syntaxCont{\Sref \Exp}{}
%\syntaxCont{\alert{\Exp} \terminal{:=} \Exp}{}
%\syntaxCont{\terminal{!} \alert{\Exp}}{}
%\item[] \syntax[\structure{T}]{{\Sint}\Smid {\Sbool}\Smid {\Sunit}\Smid \structure{T} \rightarrow \structure{T} \Smid \structure{T} \Sref}{} 
%	\end{itemize}
%}
%\end{syntaxBlock}
%\begin{block}{}
%\begin{itemize}
%\item Se elimină locațiile din sintaxă 
%\item Se permite folosirea de expresii în locul locațiilor 
%\begin{itemize}\item la atribuire și dereferențiere \end{itemize}
%\item Se introduce o nouă construcție pentru creerea de locații.
%\end{itemize}
%\end{block}
%
%\end{frame}
%
%\begin{frame}{Semantică intuitivă}
%\begin{description}
%\item[$\Sref e$] Alocă o nouă locație de memorie în care stochează (valoarea expresiei) $e$ și se evaluează la o referință la acea locație.
%\vitem[$\terminal{!} e$] Se așteaptă ca $e$ să se evalueze la o referință la o locație și în acest caz se evaluează la valoarea stocată în memorie la acea locație.
%\vitem[$e_1 \terminal{:=} e_2$] Se așteaptă ca $e_1$ să se evalueze la o referință la o locație și în acest caz stochează în acea locație (valoarea expresiei) $e_2$.
%\end{description}
%\end{frame}
%
%
%\begin{frame}[fragile]{Referințe}{Exemple}
%\begin{minipage}{.35\columnwidth}
%\begin{asciiml}
%let x = ref 10 in
%let s = ref 0 in
%  while 1 <= !x do
%    s := !s + !x;
%    x := !x + -1
%  done
%\end{asciiml}
%\end{minipage}
%\hfill
%\begin{minipage}{.60\columnwidth}
%\begin{asciiml}
%let f = ref (fun (x : int) -> x) in
%f := (fun (x : int) -> if x <= 0 
%                       then 0 
%                       else x + !f (x + -1)) ;
%!f 100
%\end{asciiml}
%\end{minipage}
%\end{frame}
%
%
%\begin{frame}{Tipuri pentru referințe}
%\begin{block}{Mediul de tipuri}
%\begin{itemize}
%\item Observați că limbajul DATA-IMP nu mai are locații explicite!
%\item Așadar mediul de tipuri rămâne o funcție parțială de domeniu finit care asociază tipuri variabilelor $\Gamma : \mathbb{X} \stackrel\circ\rightarrow T$
%\end{itemize}
%\end{block}
%
%\begin{block}{Reguli de tipuri}
%\begin{itemize}
%\item[] 
%$\reg[tRef]{\tjud{\Sref e}{T \Sref}}{\tjud{e}{T}{}}{}$
%\item[]
%\item[] $\reg[tDeref]{\tjud{\terminal{!} e}{T}}{\tjud{e}{T \Sref}{}}{}$
%\item[]
%\item[]
%$\reg[tAtrib]{\tjud{e_1 \terminal{:=} e_2}{\Sunit}}{\tjud{e_1}{T \Sref}{}\si \tjud{e_2}{T}{}}{}$
%
%\end{itemize}
%\end{block}
%\end{frame}
%
%\begin{frame}{Memoria pentru DATA-IMP}
%\begin{block}{Ce putem stoca?}
%Orice: întregi, booleeni, instrucțiuni, funcții, referințe, \ldots 
%\end{block}
%
%\begin{block}{Locații}
%\begin{itemize}
%\item Întrucât nu mai apar în programe, sunt complet abstracte
%\item În implementări putem prefera întregi pentru eficiență crescută
%\end{itemize}
%\end{block}
%
%\begin{block}{Starea memoriei}
%Funcție parțială de domeniu finit de la mulțimea locațiilor la mulțimea expresiilor
%\[\sigma : \mathbb{L} \stackrel\circ\rightarrow \mathbb{E}\] 
%\end{block}
%\end{frame}
%
%\begin{frame}{Semantica referințelor}
%\begin{block}{Valori de tip referință}
%Extindem (doar pentru motive semantice) sintaxa limbajului cu valori de tip referință:
%\[\structure{v} \mathrel{::=} \structure{l}\]
%\end{block}
%\begin{block}{Reguli de reducere}
%\begin{itemize}
%\item[] $\reg[refS]{\Ss{\c{\Sref e,\sigma}}{\c{\Sref e',\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$
%
%\item[] $\reg[ref]{\Ss{\c{\Sref v,\sigma}}{\c{l,\sigma'}}}{}{l\not\in\Dom \sigma, \sigma' = \sigma[l\mapsto v]}$
%
%\item[] $\reg[derefS]{\Ss{\c{\terminal{!} e,\sigma}}{\c{\terminal{!} e',\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$
%
%\item[] $\reg[atribS]{\Ss{\c{e_1 \terminal{:=} e_2,\sigma}}{\c{e_1' \terminal{:=} e_2,\sigma'}}}{\Ss{\c{e_1,\sigma}}{\c{e_1',\sigma'}}}{}$
%\end{itemize}
%
%\structure{({\sc loc}), ({\sc atribD}) și ({\sc atrib}):} Rămân la fel ca formă, dar acum $l$ este expresie
%\end{block}
%\end{frame}
%\end{section}
%
\begin{section}{Perechi}
\begin{frame}{Perechi}
\begin{block}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\vspace{-5ex}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots}{}
\syntaxCont{(\Exp, \Exp)}{}
\syntaxCont{\terminal{fst} \Exp}{}
\syntaxCont{\terminal{snd} \Exp}{}
\item[] \syntax[\structure{T}]{\ldots \Smid \structure{T} * \structure{T}}{} 
\end{itemize}
}
\end{syntaxBlock}
\end{block}
\begin{block}{Reguli de tipuri}
\begin{itemize}
\item[] 
$\reg[tPair]{\tjud{(e_1,e_2)}{T_1 * T_2}}{\tjud{e_1}{T_1}{}\si \tjud{e_2}{T_2}{}}{}$
\item[] $\reg[tFst]{\tjud{\terminal{fst} e}{T_1}}{\tjud{e}{T_1 * T_2}{}}{}$
\item[]
$\reg[tSnd]{\tjud{\terminal{snd} e}{T_2}}{\tjud{e}{T_1 * T_2}{}}{}$

\end{itemize}

\end{block}
\end{frame}

\begin{frame}{Semantica perechilor}
\begin{block}{Valori perechi}
O pereche de valori este o valoare:
\begin{syntaxBlock}{\structure{v}}
\vspace{-5ex}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots}{}
\syntaxCont{(\structure{v}, \structure{v})}{}
\end{itemize}
}
\end{syntaxBlock}
\end{block}
\begin{block}{Reguli de reducere}
\begin{itemize}
\item[] {\small $\reg[pairS]{\Ss{\c{(e_1,e_2),\sigma}}{\c{(e_1',e_2),\sigma'}}}{\Ss{\c{e_1,\sigma}}{\c{e_1',\sigma'}}}{}$ 
\hfill $\reg[pairD]{\Ss{\c{(e_1,e_2),\sigma}}{\c{(e_1,e_2'),\sigma'}}}{\Ss{\c{e_2,\sigma}}{\c{e_2',\sigma'}}}{}$}

\item[] $\reg[fstS]{\Ss{\c{\terminal{fst} e,\sigma}}{\c{\terminal{fst} e',\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$
\hfill $\reg[sndS]{\Ss{\c{\terminal{snd} e,\sigma}}{\c{\terminal{snd} e',\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$

\item[] $\reg[fst]{\Ss{\c{\terminal{fst} (v_1,v_2),\sigma}}{\c{v_1,\sigma}}}{}{}$ 
\hfill $\reg[snd]{\Ss{\c{\terminal{snd} (v_1,v_2),\sigma}}{\c{v_2,\sigma}}}{}{}$ 

\end{itemize}
\end{block}
\end{frame}

\end{section}

\begin{section}{Tipuri Variant / Sumă / Uniune}
\begin{frame}{Tipuri Variant}
\begin{block}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\vspace{-5ex}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots}{}
\syntaxCont{\SInjL \Exp : \structure{T} \Smid \SInjR \Exp : \structure{T}}{}
\syntaxCont{\Smatch \Exp \Swith {\SInjL (\structure{x}:\structure{T}) \rightarrow \Exp} \mid {\SInjR (\structure{x}:\structure{T}) \rightarrow \Exp}}{}
\item[] \syntax[\structure{T}]{\ldots \Smid \structure{T} + \structure{T}}{} 
\end{itemize}
}
\vspace{-2ex}
\end{syntaxBlock}
\end{block}

\begin{block}{Reguli pentru tipuri}
{\small\begin{itemize}
\item[] $\reg[tInjL]{\tjud{\terminal{InjL} e : T_1 + T_2}{T_1 + T_2}}{\tjud{e}{T_1}{}}{}$
\item[] $\reg[tInjR]{\tjud{\terminal{InjR} e : T_1 + T_2}{T_1 + T_2}}{\tjud{e}{T_2}{}}{}$
\item[] 
$\reg[tMatch]{\tjud{\Smatch e \Swith {\SInjL (x:T_1) \rightarrow e_1} \mid {\SInjR (y:T_2) \rightarrow e_2}}{T}}{\tjud{e}{T_1 + T_2}{}\si \tjud[\Gamma_1]{e_1}{T}{}\si \tjud[\Gamma_2]{e_2}{T}{}}{}$

\hfill {\it dacă} $\Gamma_1 = \Gamma[x \mapsto T_1], \Gamma_2 = \Gamma[y \mapsto T_2]$ 

\end{itemize}
}
\end{block}
\end{frame}

\begin{frame}{Semantica variantelor}
\begin{block}{Valori variante. \color{black}
O variantă cu argument valoare este o valoare:}
\begin{syntaxBlock}{\structure{v}}
\vspace{-5ex}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots \Smid \SInjL \structure{v} : \structure{T} \Smid \SInjR \structure{v} : \structure{T} }{}
\end{itemize}
}
\vspace{-3ex}
\end{syntaxBlock}
\end{block}
\begin{block}{Reguli de reducere}
{\small
\begin{itemize}
\item[] $\reg[InjLS]{\Ss{\c{\SInjL e : T,\sigma}}{\c{\SInjL e' : T,\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$
\item[] $\reg[InjRS]{\Ss{\c{\SInjR e : T,\sigma}}{\c{\SInjR e' : T,\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$

\item[] $\reg[matchS]{\begin{array}{l}\c{\Smatch e \Swith {\SInjL (x:T_1) \rightarrow e_1} \mid {\SInjR (y:T_2) \rightarrow e_2},\sigma} \rightarrow \\ \c{\Smatch e' \Swith {\SInjL (x:T_1) \rightarrow e_1} \mid {\SInjR (y:T_2) \rightarrow e_2},\sigma'}\end{array}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$

\item[] $\reg[matchL]{\Ss{\c{\Smatch {\SInjL v : T} \begin{array}[t]{@{\;}c@{\;}l@{\;}}\Swith& {\SInjL (x:T_1) \rightarrow e_1}\\  \mid & {\SInjR (y:T_2) \rightarrow e_2}\end{array},\sigma}}{\c{\substapp{e_1}{\subst{\substpair{v}{x}}},\sigma}}}{}{}$

\item[] $\reg[matchR]{\Ss{\c{\Smatch {\SInjR v : T} \begin{array}[t]{@{\;}c@{\;}l@{\;}}\Swith& {\SInjL (x:T_1) \rightarrow e_1}\\  \mid & {\SInjR (y:T_2) \rightarrow e_2}\end{array},\sigma}}{\c{\substapp{e_2}{\subst{\substpair{v}{y}}},\sigma}}}{}{}$
\end{itemize}
} 
\end{block}
\end{frame}


\end{section}


\begin{section}{Date indexate (Records)}
\begin{frame}[fragile]{Date etichetate}{Sintaxă}
\begin{syntaxBlock}{\Exp}
\vspace{-5ex}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\ldots}{}
\syntaxCont{\terminal{\{} \Eticheta \terminal{=} \Exp \terminal{;} \cdots \terminal{;} \Eticheta \terminal{=} \Exp \terminal{\}}}{}
\syntaxCont{\alert{\Exp} \terminal{.} \Eticheta}{}
\item[] \syntax[\Tip]{\ldots}{} 
\syntaxCont[\Tip]{\terminal{\{} \Eticheta \terminal{:} \Tip \terminal{;} \cdots \terminal{;} \Eticheta \terminal{:} \Tip \terminal{\}}}{}
\item[]  
\syntax[\Eticheta]{\mbox{nume de etichetă}}{} 
	\end{itemize}
}
\end{syntaxBlock}

\begin{block}{Exemplu}
\hfill\begin{minipage}{.75\columnwidth}
\begin{asciiml}
let salariuNou = fun (x:{salariu:int;licentiat:bool}) 
   -> if x.licentiat then x.salariu + 100
                     else x.salariu
in salariuNou {salariu=2000; licentiat=true }
\end{asciiml}
\end{minipage}
\hfill\;
\end{block}
\end{frame}

\begin{frame}[fragile]{Încapsulare}
\begin{block}{Java}
\vspace{-2ex}\hspace{2em}\begin{minipage}{.8\columnwidth}
\begin{asciijava}
class Counter {
  private int x = 0;
  void inc() { x = x + 1; }
  int get() { return x; }
  public static void main(String[] args) {
    Counter counter = new Counter();
    counter.inc();counter.inc(); System.out.println(counter.get());
  }
}
\end{asciijava}
\end{minipage}
\end{block}

\onslide<2>
\begin{block}{RECORD-IMP}
\vspace{-2ex}\hspace{2em}\begin{minipage}{.8\columnwidth}
\begin{asciiml}
let counter = let x = ref 0 in {
  get = fun (u : unit) -> !x ;
  inc = fun (u : unit) -> x := !x + 1 
} 
in counter.inc();counter.inc();counter.get()      
\end{asciiml}
\end{minipage}
\end{block}
\end{frame}


\begin{frame}{Date etichetate}{Semantică intuitivă}

\begin{block}{Produse generalizate}
Ne putem gândi la datele etichetate ca la o generalizare a perechilor/tuplurilor/datelor de tip produs.
\begin{itemize}
\item etichetele ne ajută să identificăm mai ușor mulțimea de proveniență
\end{itemize}
\end{block}

\vfill
\begin{description}
\item[$\{\Eticheta_1 = \Exp_1;\cdots;\Eticheta_n=\Exp_n\}$] Evaluează  expresiile $\Exp_1$, $\Exp_2$, \ldots, $\Exp_n$. 
\vitem[$\Exp \terminal{.} \Eticheta$] Se așteaptă ca $\Exp$ să se evalueze la o expresie cu etichete, dintre care o etichetă este chiar $\Eticheta$. În acest caz se evaluează la valoarea corespunzătoare acelei etichete.
\end{description}
\end{frame}

\begin{frame}{Date etichetate}{Reguli de tipuri}
\begin{itemize}
\item[] 
$\reg[tRecord]{\tjud{\{{\it et}_1 = e_1;\cdots;{\it et}_n = e_n\}}{\{{\it et}_1 : T_1;\cdots;{\it et}_n : T_n\}}}{\tjud{e_1}{T_1}{}\si\cdots\si\tjud{e_n}{T_n}{}}{}$

\hfill {\it dacă } ${\it et}_i \neq {\it et}_j$ pentru orice $i\neq j$ 
\item[] Tipul asociat fiecărei etichete este tipul expresiei asociate etichetei respective.  Observați că etichetele trebuie să fie diferite una de alta.

\vitem[] $\reg[tField]{\tjud{e\terminal{.}{\it et}}{T}}{\tjud{e}{\{{\it et}_1 : T_1;\cdots;{\it et}_n : T_n\}}{}}{\exists! i.{\it et}_i={\it et} \mbox{ și } T=T_i}$

\item[] Ca să putem alege valoarea unei etichete trebuie ca expresia să fie o structură de date etichetate care conține (o singură dată) eticheta.  Tipul rezultat este atunci tipul etichetei respective.
\end{itemize}
\end{frame}

\begin{frame}{Date etichetate}{Semantică}
\begin{itemize}
\item[] 
$\Val \mathrel{::=} \terminal{\{} \Eticheta \terminal{=} \Val \terminal{;} \cdots \terminal{;} \Eticheta \terminal{=} \Val \terminal{\}}$

\vitem[] $\reg[recordS]{\begin{array}{ll}&\c{\{{\it et}_1 = v_1;\ldots;{\it et}_{i-1}=v_{i-1};{\it et}_i = e_i;\ldots;{\it et}_{n}=e_{n}\},\sigma}\\\rightarrow&\c{\{{\it et}_1 = v_1;\ldots;{\it et}_{i-1}=v_{i-1};{\it et}_i = e_i';\ldots;{\it et}_{n}=e_{n}\},\sigma'}\end{array}}{\Ss{\c{e_i,\sigma}}{\c{e_i',\sigma'}}}{}$

Evaluez un pas o expresie etichetată dacă toate expresiile etichetate dinaintea ei sunt deja valori.

\vitem[] $\reg[fieldS]{\Ss{\c{e.{\it et},\sigma}}{\c{e'.{\it et},\sigma'}}}{\Ss{\c{e,\sigma}}{\c{e',\sigma'}}}{}$

\vitem[] $\reg[field]{\Ss{\c{\{{\it et}_1 = v_1;\ldots;{\it et}_i = v_i;\ldots;{\it et}_{n}=v_{n}\}.{\it et}_i,\sigma}}{\c{v_i,\sigma}}}{}{}$ 

Când toate expresiile sunt evaluate o aleg pe cea cu eticheta cerută.

\end{itemize}
\end{frame}
\end{section}

\begin{section}{Subtipuri}
\begin{frame}[fragile]{Polimorfism}{Necesitate}
\begin{block}{Exemplu}
\begin{asciiml}
let salariuNou = fun (x:{licentiat:bool;salariu:int}) 
   -> if x.licentiat then x.salariu + 100
                     else x.salariu
in salariuNou {varsta=22; salariu=2000; vechime=3; licentiat=true }
\end{asciiml}
\end{block}
\onslide<2>
\begin{alertblock}{Problemă}
\begin{itemize}
\item Programul de mai sus este intuitiv corect
\begin{itemize}\item Deoarece argumentul are câmpurile salariu și licențiat
\end{itemize}
\item Dar tipul lui nu corespunde cu tipul cerut de funcție
\end{itemize}
\end{alertblock}

\begin{block}{Soluție}
Permitem structuri mai complexe în locul structurilor mai simple.
\end{block}
\end{frame}

\begin{frame}[fragile]{Exemplu counter}
\begin{asciiml}
let rec addToCounter = fun (counter : {inc: unit -> unit}) -> fun (n:int) ->
  if (n<=0) then () else counter.inc();addToCounter counter (n - 1)
in let counter = let x = ref 0 in {
  get = fun (u : unit) -> !x ;
  inc = fun (u : unit) -> x := !x + 1 
} 
in addToCounter counter 3;counter.get()
\end{asciiml}
\end{frame}

\begin{frame}{Polimorfism}
\begin{block}{Definiție (Wikipedia)}
Folosirea aceleiași interfețe (funcție, metodă, operator) asupra unor entități de tipuri diferite.
\end{block}

\begin{block}{Tipuri de polimorfism}
 \begin{description}
   \item[ad hoc] Specificat de implementare, descriind toate cazurile admise
     \begin{itemize}
       \item de exemplu, supraîncărcarea operatorilor/metodelor în C++, Java
     \end{itemize}
   \item[parametric/generic] Codul nu menționează tipuri, sau folosește tipuri generice.
     \begin{itemize}
       \item de exemplu templates în C++, generics în Java, lambdas
     \end{itemize}
  \item[de subtip/de incluziune] \structure<2>{ O funcție cu parametru de clasă C poate fi aplicată oricărui obiect de clasă D dacă D este subclasă a lui C
  \begin{itemize}
    \item Specific limbajelor orientate obiect
  \end{itemize}   }
 \end{description}
\end{block}
\end{frame}

\begin{frame}[fragile]{Subtipuri}{Complexitatea problemei}
\begin{block}{Exemplu}
\begin{asciiml}
let ionel = {varsta=22;salariu=2000;educatie:{licentiat=true;doctorat=false}} in
let salariu = fun (x:{salariu:int}) -> x.salariu in
let salariuNou = fun (x:{educatie:{licentiat:bool};salariu:int}) 
   -> if x.educatie.licentiat then {salariu= x.salariu + 100; nou=true}
                              else x
in salariu ionel + salariu (salariuNou ionel)
\end{asciiml}

\end{block}
\vfill
\begin{itemize}
\item valorile expresiilor etichetate pot fi alte expresii etichetate
  \begin{itemize}
    \item Proprietatea de subtip este recursivă
  \end{itemize}
\item tipul lui if este subtipul maximal comun (latice?) 
\end{itemize}
\end{frame}

\begin{frame}{Subsumare}
\begin{block}{Intuiție}
O valoare de tipul $\{x:{\Sint};y:{\Sbool}\}$ poate fi folosită oriunde poate fi folosită o valoare de tipul $\{x:{\Sint}\}$.
\end{block}

\begin{block}{Relația de subtip}
Spunem că un tip $T$ e mai mic decât alt tip $T'$, notat $T \stip T'$ dacă valorile de tip $T$ pot fi folosite în locul celor de tip $T'$.  

Exemplu:
$\{x:{\Sint};y:{\Sbool}\} \stip \{x:{\Sint}\}$.
\end{block}

\begin{block}{Regula de subsumare}
\[\reg[subSUM]{\tjud{e}{T'}{}}{\tjud{e}{T}{}}{T\stip T'}\]
\end{block}
\end{frame}

\begin{frame}{Relația de subtip}{Reguli generale}
\begin{itemize}
\item Relația de subtip este reflexivă
\item[] $\displaystyle\reg[sRefl]{T\stip T}{}{}$
\vitem Relația de subtip este tranzitivă
\item[] $\displaystyle\reg[sTran]{T\stip T''}{T\stip T' \si T' \stip T''}{}$
\end{itemize}
\end{frame}

\begin{frame}{Tipuri de date etichetate}{Relația de subtip/subclasă}
\begin{itemize}
\item O subclasă moștenește toate câmpurile clasei părinte
\item[] $\reg[sRecordWidth]{\begin{array}{c}\{{\it et}_1 : T_1;\ldots;{\it et}_{i}:T_{i};{\it et}_{i+1} : T_{i+1};\ldots;{\it et}_{n}:T_{n}\}\\\stip\\\{{\it et}_1 : T_1;\ldots;{\it et}_{i}:T_{i}\}\end{array}}{}{}$
\vitem Câmpurile unui obiect pot fi obiecte de tipuri mai specializate decât cele declarate. 
\item[] $\displaystyle\reg[sRecordDepth]{\{{\it et}_1 : T_1;\ldots;{\it et}_{n}:T_{n}\} \stip \{{\it et}_1 : T_1';\ldots;{\it et}_{n}:T_{n}'\}}{T_1\stip T_1'\si\cdots\si T_n\stip T_n'}{}$
\end{itemize}
\end{frame} 

\begin{frame}{Tipuri de date etichetate}{Reordonarea etichetelor}
\begin{itemize}
\item Ordinea în care apar câmpurile unui obiect nu contează
\item Putem reordona câmpurile unui obiect folosind o permutare
 {\small \[\reg[sRecordOrder]{\{{\it et}_1 : T_1;\ldots;{\it et}_{n}:T_{n}\} \stip \{{\it et}_{\pi(1)} : T_{\pi(1)};\ldots;{\it et}_{\pi(n)}:T_{\pi(n)}\}}{}{}\]

\hfill {\it dacă } $\pi\in S_n$ permutare}
\end{itemize}

\begin{block}{Observații}
\begin{itemize}
\item Putem avea cicluri în relația de subtip
\item Relația de subtip este o preordine (ordine fără antisimetrie)
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Subtipuri}{Produse/Sume}
\begin{block}{Produse}
Propagă ordinea pe componente, la fel ca la tipuri etichetate:
\[
\reg[sRecordDepth]{T_1 * T_{2} \stip T_1' * T_{2}'}{T_1\stip T_1'\si T_2\stip T_2'}{}
\]
\end{block}

\vfill
\begin{block}{Sume}
Propagă ordinea pe componente, la fel ca la tipuri etichetate:
\[
\reg[sRecordDepth]{T_1 + T_{2} \stip T_1' + T_{2}'}{T_1\stip T_1'\si T_2\stip T_2'}{}
\]
\end{block}
\end{frame}

\begin{frame}[fragile]{Subtipuri}{Funcții}
\begin{block}{Exemplu}
\begin{asciiml}
let h = fun (f : {a:int;b:bool} -> {c:int;d:int}) ->
     let r = f {a=5;b=true;o=9} in r.c+r.d
in let g = fun (x: {b:bool}) -> if x.b then {c=0; d=7; e=12} 
                                       else {c=3; d=2; f=true}
in h g 
\end{asciiml}
E corect programul de mai sus? Ce funcții pot trimite ca argument lui $h$? 

\onslide<2> Cu o funcție care 
\begin{itemize} 
\item ia argumente de clasa mai de bază (\structure{contravariant})
\item  produce rezultate de clasă mai specializată
(\structure{covariant})
\end{itemize}
\end{block}

\begin{block}<2>{Regula de subtip}
\[\reg[sFun]{S_1 \rightarrow S_2 \stip T_1 \rightarrow T_2}{T_1 \stip S_1 \si S_2\stip T_2}{}\] 
\end{block}
\end{frame}



\end{section}



\end{document}